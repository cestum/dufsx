<!DOCTYPE html>
<html lang="en-US" class="h-full">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/x-icon" href="__ASSETS_PREFIX__favicon.ico">
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/easymde@2.18.0/dist/easymde.min.css"> -->
  <link rel="stylesheet" href="__ASSETS_PREFIX__index.css">
  <title>DufsX</title>
</head>

<body class="h-full font-ui bg-white text-gray-800 dark:bg-vscode-bg dark:text-vscode-text">

  <!-- Main Container -->
  <div class="flex flex-col h-full overflow-hidden">
    <!-- IDE Layout Container -->
    <div class="flex flex-1 overflow-hidden">

      <!-- Left Panel: File Tree -->
      <aside class="file-tree-panel" role="navigation" aria-label="File explorer">

        <!-- File Tree Header -->
        <div class="file-tree-header">
          <h1 class="text-sm font-semibold text-gray-700 uppercase tracking-wide dark:text-vscode-text">DufsX</h1>

          <!-- Tree Actions -->
          <div class="tree-actions flex gap-1">
            <button class="control new-file-tree btn-icon" title="New File" aria-label="Create new file">
              <svg width="14" height="14" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                <path d="M8 6.5a.5.5 0 0 1 .5.5v1.5H10a.5.5 0 0 1 0 1H8.5V11a.5.5 0 0 1-1 0V9.5H6a.5.5 0 0 1 0-1h1.5V7a.5.5 0 0 1 .5-.5z" />
                <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z" />
              </svg>
            </button>
            <button class="control new-folder-tree btn-icon" title="New Folder" aria-label="Create new folder">
              <svg width="14" height="14" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                <path d="m.5 3 .04.87a1.99 1.99 0 0 0-.342 1.311l.637 7A2 2 0 0 0 2.826 14H9v-1H2.826a1 1 0 0 1-.995-.91l-.637-7A1 1 0 0 1 2.19 4h11.62a1 1 0 0 1 .996 1.09L14.54 8h1.005l.256-2.819A2 2 0 0 0 13.81 3H9.828a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 6.172 1H2.5a2 2 0 0 0-2 2zm5.672-1a1 1 0 0 1 .707.293L7.586 3H2.19c-.24 0-.47.042-.683.12L1.5 2.98a1 1 0 0 1 1-.98h3.672z" />
                <path d="M13.5 10a.5.5 0 0 1 .5.5V12h1.5a.5.5 0 1 1 0 1H14v1.5a.5.5 0 1 1-1 0V13h-1.5a.5.5 0 0 1 0-1H13v-1.5a.5.5 0 0 1 .5-.5z" />
              </svg>
            </button>
            <button class="control refresh-tree btn-icon" title="Refresh" aria-label="Refresh file tree">
              <svg width="14" height="14" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
              </svg>
            </button>
            <div class="control upload-file hidden btn-icon" title="Upload files">
              <label for="file">
                <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                  <path
                    d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z" />
                  <path
                    d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z" />
                </svg>
              </label>
              <input type="file" id="file" title="Upload files" name="file" multiple>
            </div>
          </div>
        </div>

        <!-- File Tree Container -->
        <div class="file-tree-container">
          <div class="file-tree p-0" id="file-tree" role="tree">
            <!-- File tree populated by JavaScript -->
          </div>
          <div class="empty-folder hidden p-4 text-center text-gray-500 dark:text-vscode-text-secondary">No files found</div>
        </div>

        <footer class="flex flex-wrap items-center px-2 py-3 bg-white border-b border-gray-200 sticky top-0 z-50 dark:bg-vscode-panel dark:border-vscode-border">
          <!-- Toolbox -->
          <div class="toolbox flex items-center gap-1 mr-4">
            <!-- Toolbox controls populated by JavaScript -->
          </div>
          <!-- Upload Progress -->
          <div class="upload-progress">
            <table class="uploaders-table hidden">
              <thead>
                <tr class="border-b border-gray-200 dark:border-vscode-border">
                  <th class="cell-name text-left py-2 font-medium text-gray-700 dark:text-vscode-text">Uploading</th>
                  <th class="cell-status text-left py-2 font-medium text-gray-700 dark:text-vscode-text">Progress</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <!-- Search Bar -->
          <form class="searchbar flex items-center w-full h-8 border border-gray-100 rounded transition-all hover:border-2 duration-150 dark:bg-vscode dark:border-vscode-border">
            <div class="icon p-1 text-gray-400 cursor-pointer">
                <svg aria-hidden="true" focusable="false" class="fill-gray-600 dark:fill-vscode-text-secondary" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" display="inline-block" overflow="visible" style="vertical-align: text-bottom;"><path d="M10.68 11.74a6 6 0 0 1-7.922-8.982 6 6 0 0 1 8.982 7.922l3.04 3.04a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215ZM11.5 7a4.499 4.499 0 1 0-8.997 0A4.499 4.499 0 0 0 11.5 7Z"></path></svg>
            </div>
            <input id="search"
                   name="q"
                   type="text"
                   maxlength="100"
                   autocomplete="off"
                   tabindex="1"
                   placeholder="Search files..."
                   class="flex-1 h-full text-sm bg-transparent border-none outline-none px-1 dark:text-vscode-text">
            <input type="submit" class="hidden" />
          </form>
        </footer>
      </aside>

      <!-- Resizer -->
      <div class="resizer" role="separator" aria-orientation="vertical" aria-label="Resize file tree panel"></div>

      <!-- Right Panel: Content Viewer/Editor -->
      <main class="content-panel" role="main">

        <!-- Content Header -->
        <div class="content-header flex flex-col">
        <div class="flex flex-row justify-between w-full">
            <div class="file-info flex-1">
              <div class="file-info-header flex items-center gap-2">
                <div class="breadcrumb fill-white text-sm text-gray-600 dark:text-vscode-text-secondary"></div>
                <span class="current-file-name text-base font-medium text-gray-800 dark:text-vscode-text">No file selected</span>
              </div>
              <span class="current-file-path text-sm text-gray-500 dark:text-vscode-text-secondary"></span>
            </div>
            <div class="toolbox-right flex items-center gap-1">
              <div class="content-header-buttons flex items-center gap-1">
                <button class="save-btn hidden btn-icon" title="Save file" aria-label="Save current file">
                  <svg viewBox="0 0 1024 1024" width="16" height="16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                      <path d="M877.8,958.6c33.1,0,60-26.899,60-60V288.7c0-23.9-9.5-46.8-26.4-63.6L712.8,26.4C695.899,9.5,672.999,0,649.2,0h-15.801 v220c0,33.1-26.9,60-60,60H199.2c-33.1,0-60-26.9-60-60V0H80.8c-33.1,0-60,26.9-60,60v288.3v72v478.3c0,33.101,26.9,60,60,60h37.9 V556.7c0-33.101,26.9-60,60-60h601.299c33.102,0,60,26.899,60,60V958.6H877.8L877.8,958.6z"/>
                    <path d="M507.399,211.4c16.6,0,30-13.4,30-30V0H412.9v181.4c0,16.6,13.4,30,30,30H507.399z"/>
                  </svg>
                </button>
              </div>
              <button class="control download hidden btn-icon" title="Download file" download="" aria-label="Download selected file">
                <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z" />
                  <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z" />
                </svg>
              </button>
              <button class="control move-file hidden btn-icon" title="Move to new path">
                <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary icon-move">
                  <path fill-rule="evenodd"
                    d="M1.5 1.5A.5.5 0 0 0 1 2v4.8a2.5 2.5 0 0 0 2.5 2.5h9.793l-3.347 3.346a.5.5 0 0 0 .708.708l4.2-4.2a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 8.3H3.5A1.5 1.5 0 0 1 2 6.8V2a.5.5 0 0 0-.5-.5z">
                  </path>
                </svg>
              </button>
              <button class="control delete-file hidden btn-icon" title="Delete">
                <svg class="fill-gray-600 dark:fill-vscode-text-secondary icon-delete" width="16" height="16" viewBox="0 0 16 16">
                  <path
                    d="M6.854 7.146a.5.5 0 1 0-.708.708L7.293 9l-1.147 1.146a.5.5 0 0 0 .708.708L8 9.707l1.146 1.147a.5.5 0 0 0 .708-.708L8.707 9l1.147-1.146a.5.5 0 0 0-.708-.708L8 8.293 6.854 7.146z" />
                  <path
                    d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z" />
                </svg>
              </button>
              <button class="login-btn hidden btn-icon" title="Login" aria-label="Login">
                <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                  <path fill-rule="evenodd" d="M6 3.5a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 0-1 0v2A1.5 1.5 0 0 0 6.5 14h8a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 14.5 2h-8A1.5 1.5 0 0 0 5 3.5v2a.5.5 0 0 0 1 0v-2z" />
                  <path fill-rule="evenodd" d="M11.854 8.354a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H1.5a.5.5 0 0 0 0 1h8.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3z" />
                </svg>
              </button>
              <button class="logout-btn hidden items-center gap-2 btn-icon" title="Logout" aria-label="Logout">
                <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text-secondary">
                  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0z"/>
                  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708z"/>
                </svg>
                <span class="user-name text-sm text-gray-700 dark:text-vscode-text"></span>
              </button>
            </div>

        </div>
        <div class="content-header-custom flex flex-row justify-between w-full">
        </div>
        </div>

        <!-- Content Body -->
        <div class="content-body">

          <!-- Welcome Screen -->
          <div class="welcome-screen" id="welcome-screen">
            <div class="welcome-content">
              <h2 class="text-3xl font-bold text-gray-800 mb-4 dark:text-vscode-text">Welcome to Dufs File Explorer</h2>
              <p class="text-lg text-gray-600 mb-8 dark:text-vscode-text-secondary">Select a file from the explorer to view or edit its contents.</p>

              <div class="welcome-features">
                <div class="feature">
                  <svg width="48" height="48" viewBox="0 0 16 16" class="mx-auto mb-4 fill-blue-500 dark:fill-vscode-blue">
                    <path d="M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 .293A1 1 0 0 0 9.293 0zM9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1z"/>
                  </svg>
                  <h3 class="text-xl font-semibold text-gray-800 mb-2 dark:text-vscode-text">File Management</h3>
                  <p class="text-gray-600 dark:text-vscode-text-secondary">Browse, create, and manage files and folders</p>
                </div>
                <div class="feature">
                  <svg width="48" height="48" viewBox="0 0 16 16" class="mx-auto mb-4 fill-green-500">
                    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                  </svg>
                  <h3 class="text-xl font-semibold text-gray-800 mb-2 dark:text-vscode-text">Text Editing</h3>
                  <p class="text-gray-600 dark:text-vscode-text-secondary">Edit text files with syntax highlighting</p>
                </div>
                <div class="feature">
                  <svg width="48" height="48" viewBox="0 0 16 16" class="mx-auto mb-4 fill-purple-500">
                    <path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V9H9.5a.5.5 0 0 0-.5.5v4H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z"/>
                    <path d="M11.5 10.5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5h2z"/>
                  </svg>
                  <h3 class="text-xl font-semibold text-gray-800 mb-2 dark:text-vscode-text">Markdown Support</h3>
                  <p class="text-gray-600 dark:text-vscode-text-secondary">Enhanced markdown editing with live preview</p>
                </div>
              </div>
            </div>
          </div>

          <!-- File Content Area -->
          <div class="file-content hidden h-full" id="file-content">
            <div class="not-editable hidden p-4 bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-200">
              Cannot edit because file is too large or binary.
            </div>

            <!-- Text/Code Editor -->
            <div class="editor-container hidden h-full"></div>
            <div class="directory-container hidden h-full"></div>
            <div class="empty-folder hidden items-center justify-center h-full text-gray-500 dark:text-vscode-text-secondary">No files found</div>

            <!-- Tables for upload and path listing -->
            <table class="uploaders-table hidden w-full">
              <thead>
                <tr class="bg-gray-50 border-b border-gray-200 dark:bg-vscode-panel dark:border-vscode-border">
                  <th class="cell-name text-left py-3 px-4 font-medium text-gray-700 dark:text-vscode-text" colspan="2">Name</th>
                  <th class="cell-status text-left py-3 px-4 font-medium text-gray-700 dark:text-vscode-text">Progress</th>
                </tr>
              </thead>
            </table>
            <textarea id="editor" class="editor hidden w-full h-full p-4 font-mono text-sm bg-white border-none outline-none resize-none dark:bg-vscode-bg dark:text-vscode-text" aria-label="Editor" cols="10"></textarea>

            <!-- Markdown Editor -->
            <div id="markdown-editor-container" class="markdown-editor-container hidden h-full"></div>

            <!-- Image Viewer -->
            <div class="image-viewer hidden" id="image-viewer">
              <div class="media-toolbar">
                <div class="media-controls">
                  <button class="btn-icon" id="zoom-out" title="Zoom Out" aria-label="Zoom out">
                    <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text">
                      <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                      <path d="M4 6.5h6a.5.5 0 0 1 0 1H4a.5.5 0 0 1 0-1z"/>
                    </svg>
                  </button>
                  <span class="zoom-level px-2 py-1 text-sm font-medium text-gray-700 dark:text-vscode-text">100%</span>
                  <button class="btn-icon" id="zoom-in" title="Zoom In" aria-label="Zoom in">
                    <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text">
                      <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                      <path d="M7 4a.5.5 0 0 1 .5.5v2h2a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2h-2a.5.5 0 0 1 0-1h2v-2A.5.5 0 0 1 7 4z"/>
                    </svg>
                  </button>
                  <button class="btn-icon" id="fit-to-screen" title="Fit to Screen" aria-label="Fit to screen">
                    <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text">
                      <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                    </svg>
                  </button>
                  <button class="btn-icon" id="actual-size" title="Actual Size">
                    <svg width="16" height="16" viewBox="0 0 16 16">
                      <path d="M6.5 0A6.5 6.5 0 0 0 0 6.5C0 10.09 2.91 13 6.5 13S13 10.09 13 6.5A6.5 6.5 0 0 0 6.5 0zm0 12C3.46 12 1 9.54 1 6.5S3.46 1 6.5 1S12 3.46 12 6.5S9.54 12 6.5 12z"/>
                      <path d="M6.5 7a.5.5 0 1 1 0-1 .5.5 0 0 1 0 1z"/>
                    </svg>
                  </button>
                </div>
                <div class="image-info flex items-center gap-4 text-sm text-gray-600 dark:text-vscode-text-secondary">
                  <span class="image-dimensions"></span>
                  <span class="image-size"></span>
                </div>
              </div>
              <div class="image-container flex-1 flex items-center justify-center overflow-auto p-4">
                <img id="image-display" alt="Image" draggable="false" class="max-w-full max-h-full object-contain" />
              </div>
            </div>

            <!-- PDF Viewer -->
            <div class="pdf-viewer hidden" id="pdf-viewer">
              <div class="media-toolbar">
                <div class="media-controls">
                  <button class="btn-icon" id="pdf-prev" title="Previous Page" aria-label="Previous page">
                    <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text">
                      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
                    </svg>
                  </button>
                  <span class="pdf-page-info flex items-center gap-1 text-sm">
                    <input type="number" id="pdf-page-input" min="1" value="1" class="w-16 px-2 py-1 text-center border border-gray-300 rounded bg-white text-gray-800 dark:border-vscode-border dark:bg-vscode-hover dark:text-vscode-text" />
                    <span class="text-gray-600 dark:text-vscode-text-secondary"> / </span>
                    <span id="pdf-total-pages" class="text-gray-600 dark:text-vscode-text-secondary">1</span>
                  </span>
                  <button class="btn-icon" id="pdf-next" title="Next Page" aria-label="Next page">
                    <svg width="16" height="16" viewBox="0 0 16 16" class="fill-gray-600 dark:fill-vscode-text">
                      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                  </button>
                </div>
              </div>
              <div class="flex-1 bg-white dark:bg-vscode-bg">
                <iframe id="pdf-display" width="100%" height="100%" class="w-full h-full border-none"></iframe>
              </div>
            </div>

            <!-- Video Player -->
            <div class="video-viewer hidden flex-col h-full bg-black" id="video-viewer">
              <div class="flex-1 flex items-center justify-center">
                <video id="video-display" controls preload="metadata" class="max-w-full max-h-full">
                  Your browser does not support the video tag.
                </video>
              </div>
            </div>

            <!-- Audio Player -->
            <div class="audio-viewer hidden flex-col h-full justify-center bg-gray-100 dark:bg-vscode-panel" id="audio-viewer">
              <div class="max-w-2xl mx-auto p-8 w-full">
                <div class="audio-info text-center mb-6">
                  <h3 class="audio-title text-2xl font-bold text-gray-800 mb-2 dark:text-vscode-text">Audio File</h3>
                  <div class="audio-metadata flex justify-center gap-4 text-sm text-gray-600 dark:text-vscode-text-secondary">
                    <span class="audio-duration"></span>
                    <span class="audio-filesize"></span>
                  </div>
                </div>
                <audio id="audio-display" controls preload="metadata" class="w-full">
                  Your browser does not support the audio tag.
                </audio>
              </div>
            </div>

            <!-- Generic Media Viewer -->
            <div class="media-viewer hidden items-center justify-center h-full bg-gray-50 dark:bg-vscode-panel" id="media-viewer">
              <div class="text-center max-w-md">
                <div class="mb-6">
                  <svg width="64" height="64" viewBox="0 0 16 16" class="mx-auto fill-gray-400 dark:fill-vscode-text-secondary">
                    <path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z"/>
                  </svg>
                </div>
                <h3 class="media-filename text-xl font-semibold text-gray-800 mb-2 dark:text-vscode-text"></h3>
                <p class="media-description text-gray-600 mb-6 dark:text-vscode-text-secondary">This file type cannot be previewed in the browser.</p>
                <div class="media-actions">
                  <a class="btn btn-primary" id="media-download" download>
                    <svg width="16" height="16" viewBox="0 0 16 16" class="fill-current">
                      <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                      <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                    </svg>
                    Download File
                  </a>
                </div>
              </div>
            </div>

            <!-- Legacy iframe container -->
            <div class="iframe-container hidden h-full" id="iframe-container"></div>
          </div>
        </div>
      </main>
    </div>

    <!-- Legacy index page -->
    <div class="index-page hidden">
      <div class="empty-folder hidden items-center justify-center h-full text-gray-500 dark:text-vscode-text-secondary">No files found</div>
      <table class="uploaders-table hidden w-full">
        <thead>
          <tr class="bg-gray-50 border-b border-gray-200 dark:bg-vscode-panel dark:border-vscode-border">
            <th class="cell-name text-left py-3 px-4 font-medium text-gray-700 dark:text-vscode-text" colspan="2">Name</th>
            <th class="cell-status text-left py-3 px-4 font-medium text-gray-700 dark:text-vscode-text">Progress</th>
          </tr>
        </thead>
      </table>
      <table class="paths-table hidden w-full">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Data Templates and Scripts -->
  <template id="index-data">__INDEX_DATA__</template>

  <!-- File upload input -->
  <div class="upload-file hidden">
    <input type="file" id="file" name="file" multiple aria-label="Upload files">
  </div>

  <!-- External Dependencies -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/easymde@2.18.0/dist/easymde.min.js"></script> -->
  <script src="https://code.iconify.design/iconify-icon/2.1.0/iconify-icon.min.js"></script>
  <script defer src="__ASSETS_PREFIX__codemirror.js"></script>

  <!-- CodeMirror 6 Setup -->
  <script type="module">
    const {basicSetup} = CM["codemirror"];
    const {EditorView, keymap} = CM["@codemirror/view"];
    const {EditorState, Compartment} = CM["@codemirror/state"];
    const {python} = CM['@codemirror/lang-python'];
    const {javascript} = CM['@codemirror/lang-javascript'];
    const {html} = CM['@codemirror/lang-html'];
    const {css} = CM['@codemirror/lang-css'];
    const {cpp} = CM['@codemirror/lang-cpp'];
    const {java} = CM['@codemirror/lang-java'];
    const {rust} = CM['@codemirror/lang-rust'];
    const {json} = CM['@codemirror/lang-json'];
    const {php} = CM['@codemirror/lang-php'];
    const {xml} = CM['@codemirror/lang-xml'];
    const {sql} = CM['@codemirror/lang-sql'];
    const {markdown} = CM['@codemirror/lang-markdown'];
    const {oneDark} = CM['@codemirror/theme-one-dark'];
    // const {languages} = CM['@codemirror/language'];

    let languageCompartment = new Compartment;
    window.CodeMirror6 = {
      basicSetup,
      EditorView,
      EditorState,
      languageCompartment,
      languages: {
        javascript, python, java, cpp, rust, php, html, css, json, xml, sql, markdown,
      },
      // languages_data:{
      //   languages
      // },
      themes: { oneDark }
    };

    window.dispatchEvent(new CustomEvent('codemirror-ready'));
    var chunmde=function(require$$0$1,require$$0,require$$2,require$$3){"use strict";function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x.default:x}var hasRequiredDist$3,outTsc={},dist$3={},dist$2={},dist$1={};function requireDist$3(){return hasRequiredDist$3||(hasRequiredDist$3=1,function(exports){const DefaultBufferLength=1024;let nextPropID=0;class Range{constructor(from,to){this.from=from,this.to=to}}class NodeProp{constructor(config={}){this.id=nextPropID++,this.perNode=!!config.perNode,this.deserialize=config.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")})}add(match){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return"function"!=typeof match&&(match=NodeType.match(match)),type=>{let result=match(type);return void 0===result?null:[this,result]}}}NodeProp.closedBy=new NodeProp({deserialize:str=>str.split(" ")}),NodeProp.openedBy=new NodeProp({deserialize:str=>str.split(" ")}),NodeProp.group=new NodeProp({deserialize:str=>str.split(" ")}),NodeProp.isolate=new NodeProp({deserialize:value=>{if(value&&"rtl"!=value&&"ltr"!=value&&"auto"!=value)throw new RangeError("Invalid value for isolate: "+value);return value||"auto"}}),NodeProp.contextHash=new NodeProp({perNode:!0}),NodeProp.lookAhead=new NodeProp({perNode:!0}),NodeProp.mounted=new NodeProp({perNode:!0});class MountedTree{constructor(tree,overlay,parser){this.tree=tree,this.overlay=overlay,this.parser=parser}static get(tree){return tree&&tree.props&&tree.props[NodeProp.mounted.id]}}const noProps=Object.create(null);class NodeType{constructor(name,props,id,flags=0){this.name=name,this.props=props,this.id=id,this.flags=flags}static define(spec){let props=spec.props&&spec.props.length?Object.create(null):noProps,flags=(spec.top?1:0)|(spec.skipped?2:0)|(spec.error?4:0)|(null==spec.name?8:0),type=new NodeType(spec.name||"",props,spec.id,flags);if(spec.props)for(let src of spec.props)if(Array.isArray(src)||(src=src(type)),src){if(src[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");props[src[0].id]=src[1]}return type}prop(prop){return this.props[prop.id]}get isTop(){return(1&this.flags)>0}get isSkipped(){return(2&this.flags)>0}get isError(){return(4&this.flags)>0}get isAnonymous(){return(8&this.flags)>0}is(name){if("string"==typeof name){if(this.name==name)return!0;let group=this.prop(NodeProp.group);return!!group&&group.indexOf(name)>-1}return this.id==name}static match(map){let direct=Object.create(null);for(let prop in map)for(let name of prop.split(" "))direct[name]=map[prop];return node=>{for(let groups=node.prop(NodeProp.group),i=-1;i<(groups?groups.length:0);i++){let found=direct[i<0?node.name:groups[i]];if(found)return found}}}}NodeType.none=new NodeType("",Object.create(null),0,8);class NodeSet{constructor(types){this.types=types;for(let i=0;i<types.length;i++)if(types[i].id!=i)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...props){let newTypes=[];for(let type of this.types){let newProps=null;for(let source of props){let add=source(type);add&&(newProps||(newProps=Object.assign({},type.props)),newProps[add[0].id]=add[1])}newTypes.push(newProps?new NodeType(type.name,newProps,type.id,type.flags):type)}return new NodeSet(newTypes)}}const CachedNode=new WeakMap,CachedInnerNode=new WeakMap;var IterMode;exports.IterMode=void 0,(IterMode=exports.IterMode||(exports.IterMode={}))[IterMode.ExcludeBuffers=1]="ExcludeBuffers",IterMode[IterMode.IncludeAnonymous=2]="IncludeAnonymous",IterMode[IterMode.IgnoreMounts=4]="IgnoreMounts",IterMode[IterMode.IgnoreOverlays=8]="IgnoreOverlays";class Tree{constructor(type,children,positions,length,props){if(this.type=type,this.children=children,this.positions=positions,this.length=length,this.props=null,props&&props.length){this.props=Object.create(null);for(let[prop,value]of props)this.props["number"==typeof prop?prop:prop.id]=value}}toString(){let mounted=MountedTree.get(this);if(mounted&&!mounted.overlay)return mounted.tree.toString();let children="";for(let ch of this.children){let str=ch.toString();str&&(children&&(children+=","),children+=str)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(children.length?"("+children+")":""):children}cursor(mode=0){return new TreeCursor(this.topNode,mode)}cursorAt(pos,side=0,mode=0){let scope=CachedNode.get(this)||this.topNode,cursor=new TreeCursor(scope);return cursor.moveTo(pos,side),CachedNode.set(this,cursor._tree),cursor}get topNode(){return new TreeNode(this,0,0,null)}resolve(pos,side=0){let node=resolveNode(CachedNode.get(this)||this.topNode,pos,side,!1);return CachedNode.set(this,node),node}resolveInner(pos,side=0){let node=resolveNode(CachedInnerNode.get(this)||this.topNode,pos,side,!0);return CachedInnerNode.set(this,node),node}resolveStack(pos,side=0){return function(tree,pos,side){let inner=tree.resolveInner(pos,side),layers=null;for(let scan=inner instanceof TreeNode?inner:inner.context.parent;scan;scan=scan.parent)if(scan.index<0){let parent=scan.parent;(layers||(layers=[inner])).push(parent.resolve(pos,side)),scan=parent}else{let mount=MountedTree.get(scan.tree);if(mount&&mount.overlay&&mount.overlay[0].from<=pos&&mount.overlay[mount.overlay.length-1].to>=pos){let root=new TreeNode(mount.tree,mount.overlay[0].from+scan.from,-1,scan);(layers||(layers=[inner])).push(resolveNode(root,pos,side,!1))}}return layers?iterStack(layers):inner}(this,pos,side)}iterate(spec){let{enter:enter,leave:leave,from:from=0,to:to=this.length}=spec,mode=spec.mode||0,anon=(mode&exports.IterMode.IncludeAnonymous)>0;for(let c=this.cursor(mode|exports.IterMode.IncludeAnonymous);;){let entered=!1;if(c.from<=to&&c.to>=from&&(!anon&&c.type.isAnonymous||!1!==enter(c))){if(c.firstChild())continue;entered=!0}for(;entered&&leave&&(anon||!c.type.isAnonymous)&&leave(c),!c.nextSibling();){if(!c.parent())return;entered=!0}}}prop(prop){return prop.perNode?this.props?this.props[prop.id]:void 0:this.type.prop(prop)}get propValues(){let result=[];if(this.props)for(let id in this.props)result.push([+id,this.props[id]]);return result}balance(config={}){return this.children.length<=8?this:balanceRange(NodeType.none,this.children,this.positions,0,this.children.length,0,this.length,((children,positions,length)=>new Tree(this.type,children,positions,length,this.propValues)),config.makeTree||((children,positions,length)=>new Tree(NodeType.none,children,positions,length)))}static build(data){return function(data){var _a;let{buffer:buffer,nodeSet:nodeSet,maxBufferLength:maxBufferLength=DefaultBufferLength,reused:reused=[],minRepeatType:minRepeatType=nodeSet.types.length}=data,cursor=Array.isArray(buffer)?new FlatBufferCursor(buffer,buffer.length):buffer,types=nodeSet.types,contextHash=0,lookAhead=0;function takeNode(parentStart,minPos,children,positions,inRepeat,depth){let{id:id,start:start,end:end,size:size}=cursor,lookAheadAtStart=lookAhead,contextAtStart=contextHash;for(;size<0;){if(cursor.next(),-1==size){let node=reused[id];return children.push(node),void positions.push(start-parentStart)}if(-3==size)return void(contextHash=id);if(-4==size)return void(lookAhead=id);throw new RangeError(`Unrecognized record size: ${size}`)}let node,buffer,type=types[id],startPos=start-parentStart;if(end-start<=maxBufferLength&&(buffer=findBufferSize(cursor.pos-minPos,inRepeat))){let data=new Uint16Array(buffer.size-buffer.skip),endPos=cursor.pos-buffer.size,index=data.length;for(;cursor.pos>endPos;)index=copyToBuffer(buffer.start,data,index);node=new TreeBuffer(data,end-buffer.start,nodeSet),startPos=buffer.start-parentStart}else{let endPos=cursor.pos-size;cursor.next();let localChildren=[],localPositions=[],localInRepeat=id>=minRepeatType?id:-1,lastGroup=0,lastEnd=end;for(;cursor.pos>endPos;)localInRepeat>=0&&cursor.id==localInRepeat&&cursor.size>=0?(cursor.end<=lastEnd-maxBufferLength&&(makeRepeatLeaf(localChildren,localPositions,start,lastGroup,cursor.end,lastEnd,localInRepeat,lookAheadAtStart,contextAtStart),lastGroup=localChildren.length,lastEnd=cursor.end),cursor.next()):depth>2500?takeFlatNode(start,endPos,localChildren,localPositions):takeNode(start,endPos,localChildren,localPositions,localInRepeat,depth+1);if(localInRepeat>=0&&lastGroup>0&&lastGroup<localChildren.length&&makeRepeatLeaf(localChildren,localPositions,start,lastGroup,start,lastEnd,localInRepeat,lookAheadAtStart,contextAtStart),localChildren.reverse(),localPositions.reverse(),localInRepeat>-1&&lastGroup>0){let make=makeBalanced(type,contextAtStart);node=balanceRange(type,localChildren,localPositions,0,localChildren.length,0,end-start,make,make)}else node=makeTree(type,localChildren,localPositions,end-start,lookAheadAtStart-end,contextAtStart)}children.push(node),positions.push(startPos)}function takeFlatNode(parentStart,minPos,children,positions){let nodes=[],nodeCount=0,stopAt=-1;for(;cursor.pos>minPos;){let{id:id,start:start,end:end,size:size}=cursor;if(size>4)cursor.next();else{if(stopAt>-1&&start<stopAt)break;stopAt<0&&(stopAt=end-maxBufferLength),nodes.push(id,start,end),nodeCount++,cursor.next()}}if(nodeCount){let buffer=new Uint16Array(4*nodeCount),start=nodes[nodes.length-2];for(let i=nodes.length-3,j=0;i>=0;i-=3)buffer[j++]=nodes[i],buffer[j++]=nodes[i+1]-start,buffer[j++]=nodes[i+2]-start,buffer[j++]=j;children.push(new TreeBuffer(buffer,nodes[2]-start,nodeSet)),positions.push(start-parentStart)}}function makeBalanced(type,contextHash){return(children,positions,length)=>{let last,lookAheadProp,lookAhead=0,lastI=children.length-1;if(lastI>=0&&(last=children[lastI])instanceof Tree){if(!lastI&&last.type==type&&last.length==length)return last;(lookAheadProp=last.prop(NodeProp.lookAhead))&&(lookAhead=positions[lastI]+last.length+lookAheadProp)}return makeTree(type,children,positions,length,lookAhead,contextHash)}}function makeRepeatLeaf(children,positions,base,i,from,to,type,lookAhead,contextHash){let localChildren=[],localPositions=[];for(;children.length>i;)localChildren.push(children.pop()),localPositions.push(positions.pop()+base-from);children.push(makeTree(nodeSet.types[type],localChildren,localPositions,to-from,lookAhead-to,contextHash)),positions.push(from-base)}function makeTree(type,children,positions,length,lookAhead,contextHash,props){if(contextHash){let pair=[NodeProp.contextHash,contextHash];props=props?[pair].concat(props):[pair]}if(lookAhead>25){let pair=[NodeProp.lookAhead,lookAhead];props=props?[pair].concat(props):[pair]}return new Tree(type,children,positions,length,props)}function findBufferSize(maxSize,inRepeat){let fork=cursor.fork(),size=0,start=0,skip=0,minStart=fork.end-maxBufferLength,result={size:0,start:0,skip:0};scan:for(let minPos=fork.pos-maxSize;fork.pos>minPos;){let nodeSize=fork.size;if(fork.id==inRepeat&&nodeSize>=0){result.size=size,result.start=start,result.skip=skip,skip+=4,size+=4,fork.next();continue}let startPos=fork.pos-nodeSize;if(nodeSize<0||startPos<minPos||fork.start<minStart)break;let localSkipped=fork.id>=minRepeatType?4:0,nodeStart=fork.start;for(fork.next();fork.pos>startPos;){if(fork.size<0){if(-3!=fork.size)break scan;localSkipped+=4}else fork.id>=minRepeatType&&(localSkipped+=4);fork.next()}start=nodeStart,size+=nodeSize,skip+=localSkipped}return(inRepeat<0||size==maxSize)&&(result.size=size,result.start=start,result.skip=skip),result.size>4?result:void 0}function copyToBuffer(bufferStart,buffer,index){let{id:id,start:start,end:end,size:size}=cursor;if(cursor.next(),size>=0&&id<minRepeatType){let startIndex=index;if(size>4){let endPos=cursor.pos-(size-4);for(;cursor.pos>endPos;)index=copyToBuffer(bufferStart,buffer,index)}buffer[--index]=startIndex,buffer[--index]=end-bufferStart,buffer[--index]=start-bufferStart,buffer[--index]=id}else-3==size?contextHash=id:-4==size&&(lookAhead=id);return index}let children=[],positions=[];for(;cursor.pos>0;)takeNode(data.start||0,data.bufferStart||0,children,positions,-1,0);let length=null!==(_a=data.length)&&void 0!==_a?_a:children.length?positions[0]+children[0].length:0;return new Tree(types[data.topID],children.reverse(),positions.reverse(),length)}(data)}}Tree.empty=new Tree(NodeType.none,[],[],0);class FlatBufferCursor{constructor(buffer,index){this.buffer=buffer,this.index=index}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new FlatBufferCursor(this.buffer,this.index)}}class TreeBuffer{constructor(buffer,length,set){this.buffer=buffer,this.length=length,this.set=set}get type(){return NodeType.none}toString(){let result=[];for(let index=0;index<this.buffer.length;)result.push(this.childString(index)),index=this.buffer[index+3];return result.join(",")}childString(index){let id=this.buffer[index],endIndex=this.buffer[index+3],type=this.set.types[id],result=type.name;if(/\W/.test(result)&&!type.isError&&(result=JSON.stringify(result)),endIndex==(index+=4))return result;let children=[];for(;index<endIndex;)children.push(this.childString(index)),index=this.buffer[index+3];return result+"("+children.join(",")+")"}findChild(startIndex,endIndex,dir,pos,side){let{buffer:buffer}=this,pick=-1;for(let i=startIndex;i!=endIndex&&!(checkSide(side,pos,buffer[i+1],buffer[i+2])&&(pick=i,dir>0));i=buffer[i+3]);return pick}slice(startI,endI,from){let b=this.buffer,copy=new Uint16Array(endI-startI),len=0;for(let i=startI,j=0;i<endI;){copy[j++]=b[i++],copy[j++]=b[i++]-from;let to=copy[j++]=b[i++]-from;copy[j++]=b[i++]-startI,len=Math.max(len,to)}return new TreeBuffer(copy,len,this.set)}}function checkSide(side,pos,from,to){switch(side){case-2:return from<pos;case-1:return to>=pos&&from<pos;case 0:return from<pos&&to>pos;case 1:return from<=pos&&to>pos;case 2:return to>pos;case 4:return!0}}function resolveNode(node,pos,side,overlays){for(var _a;node.from==node.to||(side<1?node.from>=pos:node.from>pos)||(side>-1?node.to<=pos:node.to<pos);){let parent=!overlays&&node instanceof TreeNode&&node.index<0?null:node.parent;if(!parent)return node;node=parent}let mode=overlays?0:exports.IterMode.IgnoreOverlays;if(overlays)for(let scan=node,parent=scan.parent;parent;scan=parent,parent=scan.parent)scan instanceof TreeNode&&scan.index<0&&(null===(_a=parent.enter(pos,side,mode))||void 0===_a?void 0:_a.from)!=scan.from&&(node=parent);for(;;){let inner=node.enter(pos,side,mode);if(!inner)return node;node=inner}}class BaseNode{cursor(mode=0){return new TreeCursor(this,mode)}getChild(type,before=null,after=null){let r=getChildren(this,type,before,after);return r.length?r[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}resolve(pos,side=0){return resolveNode(this,pos,side,!1)}resolveInner(pos,side=0){return resolveNode(this,pos,side,!0)}matchContext(context){return matchNodeContext(this.parent,context)}enterUnfinishedNodesBefore(pos){let scan=this.childBefore(pos),node=this;for(;scan;){let last=scan.lastChild;if(!last||last.to!=scan.to)break;last.type.isError&&last.from==last.to?(node=scan,scan=last.prevSibling):scan=last}return node}get node(){return this}get next(){return this.parent}}class TreeNode extends BaseNode{constructor(_tree,from,index,_parent){super(),this._tree=_tree,this.from=from,this.index=index,this._parent=_parent}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(i,dir,pos,side,mode=0){for(let parent=this;;){for(let{children:children,positions:positions}=parent._tree,e=dir>0?children.length:-1;i!=e;i+=dir){let next=children[i],start=positions[i]+parent.from;if(checkSide(side,pos,start,start+next.length))if(next instanceof TreeBuffer){if(mode&exports.IterMode.ExcludeBuffers)continue;let index=next.findChild(0,next.buffer.length,dir,pos-start,side);if(index>-1)return new BufferNode(new BufferContext(parent,next,i,start),null,index)}else if(mode&exports.IterMode.IncludeAnonymous||!next.type.isAnonymous||hasChild(next)){let mounted;if(!(mode&exports.IterMode.IgnoreMounts)&&(mounted=MountedTree.get(next))&&!mounted.overlay)return new TreeNode(mounted.tree,start,i,parent);let inner=new TreeNode(next,start,i,parent);return mode&exports.IterMode.IncludeAnonymous||!inner.type.isAnonymous?inner:inner.nextChild(dir<0?next.children.length-1:0,dir,pos,side)}}if(mode&exports.IterMode.IncludeAnonymous||!parent.type.isAnonymous)return null;if(i=parent.index>=0?parent.index+dir:dir<0?-1:parent._parent._tree.children.length,parent=parent._parent,!parent)return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(pos){return this.nextChild(0,1,pos,2)}childBefore(pos){return this.nextChild(this._tree.children.length-1,-1,pos,-2)}enter(pos,side,mode=0){let mounted;if(!(mode&exports.IterMode.IgnoreOverlays)&&(mounted=MountedTree.get(this._tree))&&mounted.overlay){let rPos=pos-this.from;for(let{from:from,to:to}of mounted.overlay)if((side>0?from<=rPos:from<rPos)&&(side<0?to>=rPos:to>rPos))return new TreeNode(mounted.tree,mounted.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,pos,side,mode)}nextSignificantParent(){let val=this;for(;val.type.isAnonymous&&val._parent;)val=val._parent;return val}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}get tree(){return this._tree}toTree(){return this._tree}toString(){return this._tree.toString()}}function getChildren(node,type,before,after){let cur=node.cursor(),result=[];if(!cur.firstChild())return result;if(null!=before)for(let found=!1;!found;)if(found=cur.type.is(before),!cur.nextSibling())return result;for(;;){if(null!=after&&cur.type.is(after))return result;if(cur.type.is(type)&&result.push(cur.node),!cur.nextSibling())return null==after?result:[]}}function matchNodeContext(node,context,i=context.length-1){for(let p=node;i>=0;p=p.parent){if(!p)return!1;if(!p.type.isAnonymous){if(context[i]&&context[i]!=p.name)return!1;i--}}return!0}class BufferContext{constructor(parent,buffer,index,start){this.parent=parent,this.buffer=buffer,this.index=index,this.start=start}}class BufferNode extends BaseNode{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(context,_parent,index){super(),this.context=context,this._parent=_parent,this.index=index,this.type=context.buffer.set.types[context.buffer.buffer[index]]}child(dir,pos,side){let{buffer:buffer}=this.context,index=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,pos-this.context.start,side);return index<0?null:new BufferNode(this.context,this,index)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(pos){return this.child(1,pos,2)}childBefore(pos){return this.child(-1,pos,-2)}enter(pos,side,mode=0){if(mode&exports.IterMode.ExcludeBuffers)return null;let{buffer:buffer}=this.context,index=buffer.findChild(this.index+4,buffer.buffer[this.index+3],side>0?1:-1,pos-this.context.start,side);return index<0?null:new BufferNode(this.context,this,index)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(dir){return this._parent?null:this.context.parent.nextChild(this.context.index+dir,dir,0,4)}get nextSibling(){let{buffer:buffer}=this.context,after=buffer.buffer[this.index+3];return after<(this._parent?buffer.buffer[this._parent.index+3]:buffer.buffer.length)?new BufferNode(this.context,this._parent,after):this.externalSibling(1)}get prevSibling(){let{buffer:buffer}=this.context,parentStart=this._parent?this._parent.index+4:0;return this.index==parentStart?this.externalSibling(-1):new BufferNode(this.context,this._parent,buffer.findChild(parentStart,this.index,-1,0,4))}get tree(){return null}toTree(){let children=[],positions=[],{buffer:buffer}=this.context,startI=this.index+4,endI=buffer.buffer[this.index+3];if(endI>startI){let from=buffer.buffer[this.index+1];children.push(buffer.slice(startI,endI,from)),positions.push(0)}return new Tree(this.type,children,positions,this.to-this.from)}toString(){return this.context.buffer.childString(this.index)}}function iterStack(heads){if(!heads.length)return null;let pick=0,picked=heads[0];for(let i=1;i<heads.length;i++){let node=heads[i];(node.from>picked.from||node.to<picked.to)&&(picked=node,pick=i)}let next=picked instanceof TreeNode&&picked.index<0?null:picked.parent,newHeads=heads.slice();return next?newHeads[pick]=next:newHeads.splice(pick,1),new StackIterator(newHeads,picked)}class StackIterator{constructor(heads,node){this.heads=heads,this.node=node}get next(){return iterStack(this.heads)}}class TreeCursor{get name(){return this.type.name}constructor(node,mode=0){if(this.mode=mode,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,node instanceof TreeNode)this.yieldNode(node);else{this._tree=node.context.parent,this.buffer=node.context;for(let n=node._parent;n;n=n._parent)this.stack.unshift(n.index);this.bufferNode=node,this.yieldBuf(node.index)}}yieldNode(node){return!!node&&(this._tree=node,this.type=node.type,this.from=node.from,this.to=node.to,!0)}yieldBuf(index,type){this.index=index;let{start:start,buffer:buffer}=this.buffer;return this.type=type||buffer.set.types[buffer.buffer[index]],this.from=start+buffer.buffer[index+1],this.to=start+buffer.buffer[index+2],!0}yield(node){return!!node&&(node instanceof TreeNode?(this.buffer=null,this.yieldNode(node)):(this.buffer=node.context,this.yieldBuf(node.index,node.type)))}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(dir,pos,side){if(!this.buffer)return this.yield(this._tree.nextChild(dir<0?this._tree._tree.children.length-1:0,dir,pos,side,this.mode));let{buffer:buffer}=this.buffer,index=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,pos-this.buffer.start,side);return!(index<0)&&(this.stack.push(this.index),this.yieldBuf(index))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(pos){return this.enterChild(1,pos,2)}childBefore(pos){return this.enterChild(-1,pos,-2)}enter(pos,side,mode=this.mode){return this.buffer?!(mode&exports.IterMode.ExcludeBuffers)&&this.enterChild(1,pos,side):this.yield(this._tree.enter(pos,side,mode))}parent(){if(!this.buffer)return this.yieldNode(this.mode&exports.IterMode.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let parent=this.mode&exports.IterMode.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(parent)}sibling(dir){if(!this.buffer)return!!this._tree._parent&&this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+dir,dir,0,4,this.mode));let{buffer:buffer}=this.buffer,d=this.stack.length-1;if(dir<0){let parentStart=d<0?0:this.stack[d]+4;if(this.index!=parentStart)return this.yieldBuf(buffer.findChild(parentStart,this.index,-1,0,4))}else{let after=buffer.buffer[this.index+3];if(after<(d<0?buffer.buffer.length:buffer.buffer[this.stack[d]+3]))return this.yieldBuf(after)}return d<0&&this.yield(this.buffer.parent.nextChild(this.buffer.index+dir,dir,0,4,this.mode))}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(dir){let index,parent,{buffer:buffer}=this;if(buffer){if(dir>0){if(this.index<buffer.buffer.buffer.length)return!1}else for(let i=0;i<this.index;i++)if(buffer.buffer.buffer[i+3]<this.index)return!1;({index:index,parent:parent}=buffer)}else({index:index,_parent:parent}=this._tree);for(;parent;({index:index,_parent:parent}=parent))if(index>-1)for(let i=index+dir,e=dir<0?-1:parent._tree.children.length;i!=e;i+=dir){let child=parent._tree.children[i];if(this.mode&exports.IterMode.IncludeAnonymous||child instanceof TreeBuffer||!child.type.isAnonymous||hasChild(child))return!1}return!0}move(dir,enter){if(enter&&this.enterChild(dir,0,4))return!0;for(;;){if(this.sibling(dir))return!0;if(this.atLastNode(dir)||!this.parent())return!1}}next(enter=!0){return this.move(1,enter)}prev(enter=!0){return this.move(-1,enter)}moveTo(pos,side=0){for(;(this.from==this.to||(side<1?this.from>=pos:this.from>pos)||(side>-1?this.to<=pos:this.to<pos))&&this.parent(););for(;this.enterChild(1,pos,side););return this}get node(){if(!this.buffer)return this._tree;let cache=this.bufferNode,result=null,depth=0;if(cache&&cache.context==this.buffer)scan:for(let index=this.index,d=this.stack.length;d>=0;){for(let c=cache;c;c=c._parent)if(c.index==index){if(index==this.index)return c;result=c,depth=d+1;break scan}index=this.stack[--d]}for(let i=depth;i<this.stack.length;i++)result=new BufferNode(this.buffer,result,this.stack[i]);return this.bufferNode=new BufferNode(this.buffer,result,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(enter,leave){for(let depth=0;;){let mustLeave=!1;if(this.type.isAnonymous||!1!==enter(this)){if(this.firstChild()){depth++;continue}this.type.isAnonymous||(mustLeave=!0)}for(;mustLeave&&leave&&leave(this),mustLeave=this.type.isAnonymous,!this.nextSibling();){if(!depth)return;this.parent(),depth--,mustLeave=!0}}}matchContext(context){if(!this.buffer)return matchNodeContext(this.node.parent,context);let{buffer:buffer}=this.buffer,{types:types}=buffer.set;for(let i=context.length-1,d=this.stack.length-1;i>=0;d--){if(d<0)return matchNodeContext(this._tree,context,i);let type=types[buffer.buffer[this.stack[d]]];if(!type.isAnonymous){if(context[i]&&context[i]!=type.name)return!1;i--}}return!0}}function hasChild(tree){return tree.children.some((ch=>ch instanceof TreeBuffer||!ch.type.isAnonymous||hasChild(ch)))}const nodeSizeCache=new WeakMap;function nodeSize(balanceType,node){if(!balanceType.isAnonymous||node instanceof TreeBuffer||node.type!=balanceType)return 1;let size=nodeSizeCache.get(node);if(null==size){size=1;for(let child of node.children){if(child.type!=balanceType||!(child instanceof Tree)){size=1;break}size+=nodeSize(balanceType,child)}nodeSizeCache.set(node,size)}return size}function balanceRange(balanceType,children,positions,from,to,start,length,mkTop,mkTree){let total=0;for(let i=from;i<to;i++)total+=nodeSize(balanceType,children[i]);let maxChild=Math.ceil(1.5*total/8),localChildren=[],localPositions=[];return function divide(children,positions,from,to,offset){for(let i=from;i<to;){let groupFrom=i,groupStart=positions[i],groupSize=nodeSize(balanceType,children[i]);for(i++;i<to;i++){let nextSize=nodeSize(balanceType,children[i]);if(groupSize+nextSize>=maxChild)break;groupSize+=nextSize}if(i==groupFrom+1){if(groupSize>maxChild){let only=children[groupFrom];divide(only.children,only.positions,0,only.children.length,positions[groupFrom]+offset);continue}localChildren.push(children[groupFrom])}else{let length=positions[i-1]+children[i-1].length-groupStart;localChildren.push(balanceRange(balanceType,children,positions,groupFrom,i,groupStart,length,null,mkTree))}localPositions.push(groupStart+offset-start)}}(children,positions,from,to,0),(mkTop||mkTree)(localChildren,localPositions,length)}class TreeFragment{constructor(from,to,tree,offset,openStart=!1,openEnd=!1){this.from=from,this.to=to,this.tree=tree,this.offset=offset,this.open=(openStart?1:0)|(openEnd?2:0)}get openStart(){return(1&this.open)>0}get openEnd(){return(2&this.open)>0}static addTree(tree,fragments=[],partial=!1){let result=[new TreeFragment(0,tree.length,tree,0,!1,partial)];for(let f of fragments)f.to>tree.length&&result.push(f);return result}static applyChanges(fragments,changes,minGap=128){if(!changes.length)return fragments;let result=[],fI=1,nextF=fragments.length?fragments[0]:null;for(let cI=0,pos=0,off=0;;cI++){let nextC=cI<changes.length?changes[cI]:null,nextPos=nextC?nextC.fromA:1e9;if(nextPos-pos>=minGap)for(;nextF&&nextF.from<nextPos;){let cut=nextF;if(pos>=cut.from||nextPos<=cut.to||off){let fFrom=Math.max(cut.from,pos)-off,fTo=Math.min(cut.to,nextPos)-off;cut=fFrom>=fTo?null:new TreeFragment(fFrom,fTo,cut.tree,cut.offset+off,cI>0,!!nextC)}if(cut&&result.push(cut),nextF.to>nextPos)break;nextF=fI<fragments.length?fragments[fI++]:null}if(!nextC)break;pos=nextC.toA,off=nextC.toA-nextC.toB}return result}}class StringInput{constructor(string){this.string=string}get length(){return this.string.length}chunk(from){return this.string.slice(from)}get lineChunks(){return!1}read(from,to){return this.string.slice(from,to)}}class InnerParse{constructor(parser,parse,overlay,target,from){this.parser=parser,this.parse=parse,this.overlay=overlay,this.target=target,this.from=from}}function checkRanges(ranges){if(!ranges.length||ranges.some((r=>r.from>=r.to)))throw new RangeError("Invalid inner parse ranges given: "+JSON.stringify(ranges))}class ActiveOverlay{constructor(parser,predicate,mounts,index,start,target,prev){this.parser=parser,this.predicate=predicate,this.mounts=mounts,this.index=index,this.start=start,this.target=target,this.prev=prev,this.depth=0,this.ranges=[]}}const stoppedInner=new NodeProp({perNode:!0});class MixedParse{constructor(base,nest,input,fragments,ranges){this.nest=nest,this.input=input,this.fragments=fragments,this.ranges=ranges,this.inner=[],this.innerDone=0,this.baseTree=null,this.stoppedAt=null,this.baseParse=base}advance(){if(this.baseParse){let done=this.baseParse.advance();if(!done)return null;if(this.baseParse=null,this.baseTree=done,this.startInner(),null!=this.stoppedAt)for(let inner of this.inner)inner.parse.stopAt(this.stoppedAt)}if(this.innerDone==this.inner.length){let result=this.baseTree;return null!=this.stoppedAt&&(result=new Tree(result.type,result.children,result.positions,result.length,result.propValues.concat([[stoppedInner,this.stoppedAt]]))),result}let inner=this.inner[this.innerDone],done=inner.parse.advance();if(done){this.innerDone++;let props=Object.assign(Object.create(null),inner.target.props);props[NodeProp.mounted.id]=new MountedTree(done,inner.overlay,inner.parser),inner.target.props=props}return null}get parsedPos(){if(this.baseParse)return 0;let pos=this.input.length;for(let i=this.innerDone;i<this.inner.length;i++)this.inner[i].from<pos&&(pos=Math.min(pos,this.inner[i].parse.parsedPos));return pos}stopAt(pos){if(this.stoppedAt=pos,this.baseParse)this.baseParse.stopAt(pos);else for(let i=this.innerDone;i<this.inner.length;i++)this.inner[i].parse.stopAt(pos)}startInner(){let fragmentCursor=new FragmentCursor(this.fragments),overlay=null,covered=null,cursor=new TreeCursor(new TreeNode(this.baseTree,this.ranges[0].from,0,null),exports.IterMode.IncludeAnonymous|exports.IterMode.IgnoreMounts);scan:for(let nest,isCovered;;){let range,enter=!0;if(null!=this.stoppedAt&&cursor.from>=this.stoppedAt)enter=!1;else if(fragmentCursor.hasNode(cursor)){if(overlay){let match=overlay.mounts.find((m=>m.frag.from<=cursor.from&&m.frag.to>=cursor.to&&m.mount.overlay));if(match)for(let r of match.mount.overlay){let from=r.from+match.pos,to=r.to+match.pos;from>=cursor.from&&to<=cursor.to&&!overlay.ranges.some((r=>r.from<to&&r.to>from))&&overlay.ranges.push({from:from,to:to})}}enter=!1}else if(covered&&(isCovered=checkCover(covered.ranges,cursor.from,cursor.to)))enter=2!=isCovered;else if(!cursor.type.isAnonymous&&(nest=this.nest(cursor,this.input))&&(cursor.from<cursor.to||!nest.overlay)){cursor.tree||materialize(cursor);let oldMounts=fragmentCursor.findMounts(cursor.from,nest.parser);if("function"==typeof nest.overlay)overlay=new ActiveOverlay(nest.parser,nest.overlay,oldMounts,this.inner.length,cursor.from,cursor.tree,overlay);else{let ranges=punchRanges(this.ranges,nest.overlay||(cursor.from<cursor.to?[new Range(cursor.from,cursor.to)]:[]));ranges.length&&checkRanges(ranges),!ranges.length&&nest.overlay||this.inner.push(new InnerParse(nest.parser,ranges.length?nest.parser.startParse(this.input,enterFragments(oldMounts,ranges),ranges):nest.parser.startParse(""),nest.overlay?nest.overlay.map((r=>new Range(r.from-cursor.from,r.to-cursor.from))):null,cursor.tree,ranges.length?ranges[0].from:cursor.from)),nest.overlay?ranges.length&&(covered={ranges:ranges,depth:0,prev:covered}):enter=!1}}else if(overlay&&(range=overlay.predicate(cursor))&&(!0===range&&(range=new Range(cursor.from,cursor.to)),range.from<range.to)){let last=overlay.ranges.length-1;last>=0&&overlay.ranges[last].to==range.from?overlay.ranges[last]={from:overlay.ranges[last].from,to:range.to}:overlay.ranges.push(range)}if(enter&&cursor.firstChild())overlay&&overlay.depth++,covered&&covered.depth++;else for(;!cursor.nextSibling();){if(!cursor.parent())break scan;if(overlay&&! --overlay.depth){let ranges=punchRanges(this.ranges,overlay.ranges);ranges.length&&(checkRanges(ranges),this.inner.splice(overlay.index,0,new InnerParse(overlay.parser,overlay.parser.startParse(this.input,enterFragments(overlay.mounts,ranges),ranges),overlay.ranges.map((r=>new Range(r.from-overlay.start,r.to-overlay.start))),overlay.target,ranges[0].from))),overlay=overlay.prev}covered&&! --covered.depth&&(covered=covered.prev)}}}}function checkCover(covered,from,to){for(let range of covered){if(range.from>=to)break;if(range.to>from)return range.from<=from&&range.to>=to?2:1}return 0}function sliceBuf(buf,startI,endI,nodes,positions,off){if(startI<endI){let from=buf.buffer[startI+1];nodes.push(buf.slice(startI,endI,from)),positions.push(from-off)}}function materialize(cursor){let{node:node}=cursor,stack=[],buffer=node.context.buffer;do{stack.push(cursor.index),cursor.parent()}while(!cursor.tree);let base=cursor.tree,i=base.children.indexOf(buffer),buf=base.children[i],b=buf.buffer,newStack=[i];base.children[i]=function split(startI,endI,type,innerOffset,length,stackPos){let targetI=stack[stackPos],children=[],positions=[];sliceBuf(buf,startI,targetI,children,positions,innerOffset);let from=b[targetI+1],to=b[targetI+2];newStack.push(children.length);let child=stackPos?split(targetI+4,b[targetI+3],buf.set.types[b[targetI]],from,to-from,stackPos-1):node.toTree();return children.push(child),positions.push(from-innerOffset),sliceBuf(buf,b[targetI+3],endI,children,positions,innerOffset),new Tree(type,children,positions,length)}(0,b.length,NodeType.none,0,buf.length,stack.length-1);for(let index of newStack){let tree=cursor.tree.children[index],pos=cursor.tree.positions[index];cursor.yield(new TreeNode(tree,pos+cursor.from,index,cursor._tree))}}class StructureCursor{constructor(root,offset){this.offset=offset,this.done=!1,this.cursor=root.cursor(exports.IterMode.IncludeAnonymous|exports.IterMode.IgnoreMounts)}moveTo(pos){let{cursor:cursor}=this,p=pos-this.offset;for(;!this.done&&cursor.from<p;)cursor.to>=pos&&cursor.enter(p,1,exports.IterMode.IgnoreOverlays|exports.IterMode.ExcludeBuffers)||cursor.next(!1)||(this.done=!0)}hasNode(cursor){if(this.moveTo(cursor.from),!this.done&&this.cursor.from+this.offset==cursor.from&&this.cursor.tree)for(let tree=this.cursor.tree;;){if(tree==cursor.tree)return!0;if(!(tree.children.length&&0==tree.positions[0]&&tree.children[0]instanceof Tree))break;tree=tree.children[0]}return!1}}class FragmentCursor{constructor(fragments){var _a;if(this.fragments=fragments,this.curTo=0,this.fragI=0,fragments.length){let first=this.curFrag=fragments[0];this.curTo=null!==(_a=first.tree.prop(stoppedInner))&&void 0!==_a?_a:first.to,this.inner=new StructureCursor(first.tree,-first.offset)}else this.curFrag=this.inner=null}hasNode(node){for(;this.curFrag&&node.from>=this.curTo;)this.nextFrag();return this.curFrag&&this.curFrag.from<=node.from&&this.curTo>=node.to&&this.inner.hasNode(node)}nextFrag(){var _a;if(this.fragI++,this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let frag=this.curFrag=this.fragments[this.fragI];this.curTo=null!==(_a=frag.tree.prop(stoppedInner))&&void 0!==_a?_a:frag.to,this.inner=new StructureCursor(frag.tree,-frag.offset)}}findMounts(pos,parser){var _a;let result=[];if(this.inner){this.inner.cursor.moveTo(pos,1);for(let pos=this.inner.cursor.node;pos;pos=pos.parent){let mount=null===(_a=pos.tree)||void 0===_a?void 0:_a.prop(NodeProp.mounted);if(mount&&mount.parser==parser)for(let i=this.fragI;i<this.fragments.length;i++){let frag=this.fragments[i];if(frag.from>=pos.to)break;frag.tree==this.curFrag.tree&&result.push({frag:frag,pos:pos.from-frag.offset,mount:mount})}}}return result}}function punchRanges(outer,ranges){let copy=null,current=ranges;for(let i=1,j=0;i<outer.length;i++){let gapFrom=outer[i-1].to,gapTo=outer[i].from;for(;j<current.length;j++){let r=current[j];if(r.from>=gapTo)break;r.to<=gapFrom||(copy||(current=copy=ranges.slice()),r.from<gapFrom?(copy[j]=new Range(r.from,gapFrom),r.to>gapTo&&copy.splice(j+1,0,new Range(gapTo,r.to))):r.to>gapTo?copy[j--]=new Range(gapTo,r.to):copy.splice(j--,1))}}return current}function findCoverChanges(a,b,from,to){let iA=0,iB=0,inA=!1,inB=!1,pos=-1e9,result=[];for(;;){let nextA=iA==a.length?1e9:inA?a[iA].to:a[iA].from,nextB=iB==b.length?1e9:inB?b[iB].to:b[iB].from;if(inA!=inB){let start=Math.max(pos,from),end=Math.min(nextA,nextB,to);start<end&&result.push(new Range(start,end))}if(pos=Math.min(nextA,nextB),1e9==pos)break;nextA==pos&&(inA?(inA=!1,iA++):inA=!0),nextB==pos&&(inB?(inB=!1,iB++):inB=!0)}return result}function enterFragments(mounts,ranges){let result=[];for(let{pos:pos,mount:mount,frag:frag}of mounts){let startPos=pos+(mount.overlay?mount.overlay[0].from:0),endPos=startPos+mount.tree.length,from=Math.max(frag.from,startPos),to=Math.min(frag.to,endPos);if(mount.overlay){let changes=findCoverChanges(ranges,mount.overlay.map((r=>new Range(r.from+pos,r.to+pos))),from,to);for(let i=0,pos=from;;i++){let last=i==changes.length,end=last?to:changes[i].from;if(end>pos&&result.push(new TreeFragment(pos,end,mount.tree,-startPos,frag.from>=pos||frag.openStart,frag.to<=end||frag.openEnd)),last)break;pos=changes[i].to}}else result.push(new TreeFragment(from,to,mount.tree,-startPos,frag.from>=startPos||frag.openStart,frag.to<=endPos||frag.openEnd))}return result}exports.DefaultBufferLength=DefaultBufferLength,exports.MountedTree=MountedTree,exports.NodeProp=NodeProp,exports.NodeSet=NodeSet,exports.NodeType=NodeType,exports.NodeWeakMap=class{constructor(){this.map=new WeakMap}setBuffer(buffer,index,value){let inner=this.map.get(buffer);inner||this.map.set(buffer,inner=new Map),inner.set(index,value)}getBuffer(buffer,index){let inner=this.map.get(buffer);return inner&&inner.get(index)}set(node,value){node instanceof BufferNode?this.setBuffer(node.context.buffer,node.index,value):node instanceof TreeNode&&this.map.set(node.tree,value)}get(node){return node instanceof BufferNode?this.getBuffer(node.context.buffer,node.index):node instanceof TreeNode?this.map.get(node.tree):void 0}cursorSet(cursor,value){cursor.buffer?this.setBuffer(cursor.buffer.buffer,cursor.index,value):this.map.set(cursor.tree,value)}cursorGet(cursor){return cursor.buffer?this.getBuffer(cursor.buffer.buffer,cursor.index):this.map.get(cursor.tree)}},exports.Parser=class{startParse(input,fragments,ranges){return"string"==typeof input&&(input=new StringInput(input)),ranges=ranges?ranges.length?ranges.map((r=>new Range(r.from,r.to))):[new Range(0,0)]:[new Range(0,input.length)],this.createParse(input,fragments||[],ranges)}parse(input,fragments,ranges){let parse=this.startParse(input,fragments,ranges);for(;;){let done=parse.advance();if(done)return done}}},exports.Tree=Tree,exports.TreeBuffer=TreeBuffer,exports.TreeCursor=TreeCursor,exports.TreeFragment=TreeFragment,exports.parseMixed=function(nest){return(parse,input,fragments,ranges)=>new MixedParse(parse,nest,input,fragments,ranges)}}(dist$1)),dist$1}var hasRequiredDist$2,dist={};var hasRequiredStyleMod,hasRequiredDist$1,hasRequiredDist,styleMod={};function requireStyleMod(){if(hasRequiredStyleMod)return styleMod;hasRequiredStyleMod=1;var COUNT="undefined"==typeof Symbol?"__ͼ":Symbol.for("ͼ"),SET="undefined"==typeof Symbol?"__styleSet"+Math.floor(1e8*Math.random()):Symbol("styleSet"),top="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:{},StyleModule=styleMod.StyleModule=function(spec,options){this.rules=[];var finish=(options||{}).finish;function splitSelector(selector){return/^@/.test(selector)?[selector]:selector.split(/,\s*/)}function render(selectors,spec,target,isKeyframes){var local=[],isAt=/^@(\w+)\b/.exec(selectors[0]),keyframes=isAt&&"keyframes"==isAt[1];if(isAt&&null==spec)return target.push(selectors[0]+";");for(var prop in spec){var value=spec[prop];if(/&/.test(prop))render(prop.split(/,\s*/).map((function(part){return selectors.map((function(sel){return part.replace(/&/,sel)}))})).reduce((function(a,b){return a.concat(b)})),value,target);else if(value&&"object"==typeof value){if(!isAt)throw new RangeError("The value of a property ("+prop+") should be a primitive value.");render(splitSelector(prop),value,local,keyframes)}else null!=value&&local.push(prop.replace(/_.*/,"").replace(/[A-Z]/g,(function(l){return"-"+l.toLowerCase()}))+": "+value+";")}(local.length||keyframes)&&target.push((!finish||isAt||isKeyframes?selectors:selectors.map(finish)).join(", ")+" {"+local.join(" ")+"}")}for(var prop in spec)render(splitSelector(prop),spec[prop],this.rules)};StyleModule.prototype.getRules=function(){return this.rules.join("\n")},StyleModule.newName=function(){var id=top[COUNT]||1;return top[COUNT]=id+1,"ͼ"+id.toString(36)},StyleModule.mount=function(root,modules,options){var set=root[SET],nonce=options&&options.nonce;set?nonce&&set.setNonce(nonce):set=new StyleSet(root,nonce),set.mount(Array.isArray(modules)?modules:[modules],root)};var adoptedSet=new Map,StyleSet=function(root,nonce){var doc=root.ownerDocument||root,win=doc.defaultView;if(!root.head&&root.adoptedStyleSheets&&win.CSSStyleSheet){var adopted=adoptedSet.get(doc);if(adopted)return root[SET]=adopted;this.sheet=new win.CSSStyleSheet,adoptedSet.set(doc,this)}else this.styleTag=doc.createElement("style"),nonce&&this.styleTag.setAttribute("nonce",nonce);this.modules=[],root[SET]=this};return StyleSet.prototype.mount=function(modules,root){for(var sheet=this.sheet,pos=0,j=0,i=0;i<modules.length;i++){var mod=modules[i],index=this.modules.indexOf(mod);if(index<j&&index>-1&&(this.modules.splice(index,1),j--,index=-1),-1==index){if(this.modules.splice(j++,0,mod),sheet)for(var k=0;k<mod.rules.length;k++)sheet.insertRule(mod.rules[k],pos++)}else{for(;j<index;)pos+=this.modules[j++].rules.length;pos+=mod.rules.length,j++}}if(sheet)root.adoptedStyleSheets.indexOf(this.sheet)<0&&(root.adoptedStyleSheets=[this.sheet].concat(root.adoptedStyleSheets));else{for(var text="",i$1=0;i$1<this.modules.length;i$1++)text+=this.modules[i$1].getRules()+"\n";this.styleTag.textContent=text;var target=root.head||root;this.styleTag.parentNode!=target&&target.insertBefore(this.styleTag,target.firstChild)}},StyleSet.prototype.setNonce=function(nonce){this.styleTag&&this.styleTag.getAttribute("nonce")!=nonce&&this.styleTag.setAttribute("nonce",nonce)},styleMod}function requireDist$1(){if(hasRequiredDist$1)return dist$2;hasRequiredDist$1=1;var _a,common=requireDist$3(),state=require$$0,view=require$$2,highlight=function(){if(hasRequiredDist$2)return dist;hasRequiredDist$2=1,Object.defineProperty(dist,"__esModule",{value:!0});var common=requireDist$3();let nextTagID=0;class Tag{constructor(name,set,base,modified){this.name=name,this.set=set,this.base=base,this.modified=modified,this.id=nextTagID++}toString(){let{name:name}=this;for(let mod of this.modified)mod.name&&(name=`${mod.name}(${name})`);return name}static define(nameOrParent,parent){let name="string"==typeof nameOrParent?nameOrParent:"?";if(nameOrParent instanceof Tag&&(parent=nameOrParent),null==parent?void 0:parent.base)throw new Error("Can not derive from a modified tag");let tag=new Tag(name,[],null,[]);if(tag.set.push(tag),parent)for(let t of parent.set)tag.set.push(t);return tag}static defineModifier(name){let mod=new Modifier(name);return tag=>tag.modified.indexOf(mod)>-1?tag:Modifier.get(tag.base||tag,tag.modified.concat(mod).sort(((a,b)=>a.id-b.id)))}}let nextModifierID=0;class Modifier{constructor(name){this.name=name,this.instances=[],this.id=nextModifierID++}static get(base,mods){if(!mods.length)return base;let exists=mods[0].instances.find((t=>{return t.base==base&&(a=mods,b=t.modified,a.length==b.length&&a.every(((x,i)=>x==b[i])));var a,b}));if(exists)return exists;let set=[],tag=new Tag(base.name,set,base,mods);for(let m of mods)m.instances.push(tag);let configs=function(array){let sets=[[]];for(let i=0;i<array.length;i++)for(let j=0,e=sets.length;j<e;j++)sets.push(sets[j].concat(array[i]));return sets.sort(((a,b)=>b.length-a.length))}(mods);for(let parent of base.set)if(!parent.modified.length)for(let config of configs)set.push(Modifier.get(parent,config));return tag}}const ruleNodeProp=new common.NodeProp;class Rule{constructor(tags,mode,context,next){this.tags=tags,this.mode=mode,this.context=context,this.next=next}get opaque(){return 0==this.mode}get inherit(){return 1==this.mode}sort(other){return!other||other.depth<this.depth?(this.next=other,this):(other.next=this.sort(other.next),other)}get depth(){return this.context?this.context.length:0}}function tagHighlighter(tags,options){let map=Object.create(null);for(let style of tags)if(Array.isArray(style.tag))for(let tag of style.tag)map[tag.id]=style.class;else map[style.tag.id]=style.class;let{scope:scope,all:all=null}=options||{};return{style:tags=>{let cls=all;for(let tag of tags)for(let sub of tag.set){let tagClass=map[sub.id];if(tagClass){cls=cls?cls+" "+tagClass:tagClass;break}}return cls},scope:scope}}function highlightTree(tree,highlighter,putStyle,from=0,to=tree.length){let builder=new HighlightBuilder(from,Array.isArray(highlighter)?highlighter:[highlighter],putStyle);builder.highlightRange(tree.cursor(),from,to,"",builder.highlighters),builder.flush(to)}Rule.empty=new Rule([],2,null);class HighlightBuilder{constructor(at,highlighters,span){this.at=at,this.highlighters=highlighters,this.span=span,this.class=""}startSpan(at,cls){cls!=this.class&&(this.flush(at),at>this.at&&(this.at=at),this.class=cls)}flush(to){to>this.at&&this.class&&this.span(this.at,to,this.class)}highlightRange(cursor,from,to,inheritedClass,highlighters){let{type:type,from:start,to:end}=cursor;if(start>=to||end<=from)return;type.isTop&&(highlighters=this.highlighters.filter((h=>!h.scope||h.scope(type))));let cls=inheritedClass,rule=getStyleTags(cursor)||Rule.empty,tagCls=function(highlighters,tags){let result=null;for(let highlighter of highlighters){let value=highlighter.style(tags);value&&(result=result?result+" "+value:value)}return result}(highlighters,rule.tags);if(tagCls&&(cls&&(cls+=" "),cls+=tagCls,1==rule.mode&&(inheritedClass+=(inheritedClass?" ":"")+tagCls)),this.startSpan(Math.max(from,start),cls),rule.opaque)return;let mounted=cursor.tree&&cursor.tree.prop(common.NodeProp.mounted);if(mounted&&mounted.overlay){let inner=cursor.node.enter(mounted.overlay[0].from+start,1),innerHighlighters=this.highlighters.filter((h=>!h.scope||h.scope(mounted.tree.type))),hasChild=cursor.firstChild();for(let i=0,pos=start;;i++){let next=i<mounted.overlay.length?mounted.overlay[i]:null,nextPos=next?next.from+start:end,rangeFrom=Math.max(from,pos),rangeTo=Math.min(to,nextPos);if(rangeFrom<rangeTo&&hasChild)for(;cursor.from<rangeTo&&(this.highlightRange(cursor,rangeFrom,rangeTo,inheritedClass,highlighters),this.startSpan(Math.min(rangeTo,cursor.to),cls),!(cursor.to>=nextPos)&&cursor.nextSibling()););if(!next||nextPos>to)break;pos=next.to+start,pos>from&&(this.highlightRange(inner.cursor(),Math.max(from,next.from+start),Math.min(to,pos),"",innerHighlighters),this.startSpan(Math.min(to,pos),cls))}hasChild&&cursor.parent()}else if(cursor.firstChild()){mounted&&(inheritedClass="");do{if(!(cursor.to<=from)){if(cursor.from>=to)break;this.highlightRange(cursor,from,to,inheritedClass,highlighters),this.startSpan(Math.min(to,cursor.to),cls)}}while(cursor.nextSibling());cursor.parent()}}}function getStyleTags(node){let rule=node.type.prop(ruleNodeProp);for(;rule&&rule.context&&!node.matchContext(rule.context);)rule=rule.next;return rule||null}const t=Tag.define,comment=t(),name=t(),typeName=t(name),propertyName=t(name),literal=t(),string=t(literal),number=t(literal),content=t(),heading=t(content),keyword=t(),operator=t(),punctuation=t(),bracket=t(punctuation),meta=t(),tags={comment:comment,lineComment:t(comment),blockComment:t(comment),docComment:t(comment),name:name,variableName:t(name),typeName:typeName,tagName:t(typeName),propertyName:propertyName,attributeName:t(propertyName),className:t(name),labelName:t(name),namespace:t(name),macroName:t(name),literal:literal,string:string,docString:t(string),character:t(string),attributeValue:t(string),number:number,integer:t(number),float:t(number),bool:t(literal),regexp:t(literal),escape:t(literal),color:t(literal),url:t(literal),keyword:keyword,self:t(keyword),null:t(keyword),atom:t(keyword),unit:t(keyword),modifier:t(keyword),operatorKeyword:t(keyword),controlKeyword:t(keyword),definitionKeyword:t(keyword),moduleKeyword:t(keyword),operator:operator,derefOperator:t(operator),arithmeticOperator:t(operator),logicOperator:t(operator),bitwiseOperator:t(operator),compareOperator:t(operator),updateOperator:t(operator),definitionOperator:t(operator),typeOperator:t(operator),controlOperator:t(operator),punctuation:punctuation,separator:t(punctuation),bracket:bracket,angleBracket:t(bracket),squareBracket:t(bracket),paren:t(bracket),brace:t(bracket),content:content,heading:heading,heading1:t(heading),heading2:t(heading),heading3:t(heading),heading4:t(heading),heading5:t(heading),heading6:t(heading),contentSeparator:t(content),list:t(content),quote:t(content),emphasis:t(content),strong:t(content),link:t(content),monospace:t(content),strikethrough:t(content),inserted:t(),deleted:t(),changed:t(),invalid:t(),meta:meta,documentMeta:t(meta),annotation:t(meta),processingInstruction:t(meta),definition:Tag.defineModifier("definition"),constant:Tag.defineModifier("constant"),function:Tag.defineModifier("function"),standard:Tag.defineModifier("standard"),local:Tag.defineModifier("local"),special:Tag.defineModifier("special")};for(let name in tags){let val=tags[name];val instanceof Tag&&(val.name=name)}const classHighlighter=tagHighlighter([{tag:tags.link,class:"tok-link"},{tag:tags.heading,class:"tok-heading"},{tag:tags.emphasis,class:"tok-emphasis"},{tag:tags.strong,class:"tok-strong"},{tag:tags.keyword,class:"tok-keyword"},{tag:tags.atom,class:"tok-atom"},{tag:tags.bool,class:"tok-bool"},{tag:tags.url,class:"tok-url"},{tag:tags.labelName,class:"tok-labelName"},{tag:tags.inserted,class:"tok-inserted"},{tag:tags.deleted,class:"tok-deleted"},{tag:tags.literal,class:"tok-literal"},{tag:tags.string,class:"tok-string"},{tag:tags.number,class:"tok-number"},{tag:[tags.regexp,tags.escape,tags.special(tags.string)],class:"tok-string2"},{tag:tags.variableName,class:"tok-variableName"},{tag:tags.local(tags.variableName),class:"tok-variableName tok-local"},{tag:tags.definition(tags.variableName),class:"tok-variableName tok-definition"},{tag:tags.special(tags.variableName),class:"tok-variableName2"},{tag:tags.definition(tags.propertyName),class:"tok-propertyName tok-definition"},{tag:tags.typeName,class:"tok-typeName"},{tag:tags.namespace,class:"tok-namespace"},{tag:tags.className,class:"tok-className"},{tag:tags.macroName,class:"tok-macroName"},{tag:tags.propertyName,class:"tok-propertyName"},{tag:tags.operator,class:"tok-operator"},{tag:tags.comment,class:"tok-comment"},{tag:tags.meta,class:"tok-meta"},{tag:tags.invalid,class:"tok-invalid"},{tag:tags.punctuation,class:"tok-punctuation"}]);return dist.Tag=Tag,dist.classHighlighter=classHighlighter,dist.getStyleTags=getStyleTags,dist.highlightCode=function(code,tree,highlighter,putText,putBreak,from=0,to=code.length){let pos=from;function writeTo(p,classes){if(!(p<=pos)){for(let text=code.slice(pos,p),i=0;;){let nextBreak=text.indexOf("\n",i),upto=nextBreak<0?text.length:nextBreak;if(upto>i&&putText(text.slice(i,upto),classes),nextBreak<0)break;putBreak(),i=nextBreak+1}pos=p}}highlightTree(tree,highlighter,((from,to,classes)=>{writeTo(from,""),writeTo(to,classes)}),from,to),writeTo(to,"")},dist.highlightTree=highlightTree,dist.styleTags=function(spec){let byName=Object.create(null);for(let prop in spec){let tags=spec[prop];Array.isArray(tags)||(tags=[tags]);for(let part of prop.split(" "))if(part){let pieces=[],mode=2,rest=part;for(let pos=0;;){if("..."==rest&&pos>0&&pos+3==part.length){mode=1;break}let m=/^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);if(!m)throw new RangeError("Invalid path: "+part);if(pieces.push("*"==m[0]?"":'"'==m[0][0]?JSON.parse(m[0]):m[0]),pos+=m[0].length,pos==part.length)break;let next=part[pos++];if(pos==part.length&&"!"==next){mode=0;break}if("/"!=next)throw new RangeError("Invalid path: "+part);rest=part.slice(pos)}let last=pieces.length-1,inner=pieces[last];if(!inner)throw new RangeError("Invalid path: "+part);let rule=new Rule(tags,mode,last>0?pieces.slice(0,last):null);byName[inner]=rule.sort(byName[inner])}}return ruleNodeProp.add(byName)},dist.tagHighlighter=tagHighlighter,dist.tags=tags,dist}(),styleMod=requireStyleMod();const languageDataProp=new common.NodeProp;function defineLanguageFacet(baseData){return state.Facet.define({combine:baseData?values=>values.concat(baseData):void 0})}const sublanguageProp=new common.NodeProp;class Language{constructor(data,parser,extraExtensions=[],name=""){this.data=data,this.name=name,state.EditorState.prototype.hasOwnProperty("tree")||Object.defineProperty(state.EditorState.prototype,"tree",{get(){return syntaxTree(this)}}),this.parser=parser,this.extension=[language.of(this),state.EditorState.languageData.of(((state,pos,side)=>{let top=topNodeAt(state,pos,side),data=top.type.prop(languageDataProp);if(!data)return[];let base=state.facet(data),sub=top.type.prop(sublanguageProp);if(sub){let innerNode=top.resolve(pos-top.from,side);for(let sublang of sub)if(sublang.test(innerNode,state)){let data=state.facet(sublang.facet);return"replace"==sublang.type?data:data.concat(base)}}return base}))].concat(extraExtensions)}isActiveAt(state,pos,side=-1){return topNodeAt(state,pos,side).type.prop(languageDataProp)==this.data}findRegions(state){let lang=state.facet(language);if((null==lang?void 0:lang.data)==this.data)return[{from:0,to:state.doc.length}];if(!lang||!lang.allowsNesting)return[];let result=[],explore=(tree,from)=>{if(tree.prop(languageDataProp)==this.data)return void result.push({from:from,to:from+tree.length});let mount=tree.prop(common.NodeProp.mounted);if(mount){if(mount.tree.prop(languageDataProp)==this.data){if(mount.overlay)for(let r of mount.overlay)result.push({from:r.from+from,to:r.to+from});else result.push({from:from,to:from+tree.length});return}if(mount.overlay){let size=result.length;if(explore(mount.tree,mount.overlay[0].from+from),result.length>size)return}}for(let i=0;i<tree.children.length;i++){let ch=tree.children[i];ch instanceof common.Tree&&explore(ch,tree.positions[i]+from)}};return explore(syntaxTree(state),0),result}get allowsNesting(){return!0}}function topNodeAt(state,pos,side){let topLang=state.facet(language),tree=syntaxTree(state).topNode;if(!topLang||topLang.allowsNesting)for(let node=tree;node;node=node.enter(pos,side,common.IterMode.ExcludeBuffers))node.type.isTop&&(tree=node);return tree}Language.setState=state.StateEffect.define();class LRLanguage extends Language{constructor(data,parser,name){super(data,parser,[],name),this.parser=parser}static define(spec){let data=defineLanguageFacet(spec.languageData);return new LRLanguage(data,spec.parser.configure({props:[languageDataProp.add((type=>type.isTop?data:void 0))]}),spec.name)}configure(options,name){return new LRLanguage(this.data,this.parser.configure(options),name||this.name)}get allowsNesting(){return this.parser.hasWrappers()}}function syntaxTree(state){let field=state.field(Language.state,!1);return field?field.tree:common.Tree.empty}function ensureSyntaxTree(state,upto,timeout=50){var _a;let parse=null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context;if(!parse)return null;let oldVieport=parse.viewport;parse.updateViewport({from:0,to:upto});let result=parse.isDone(upto)||parse.work(timeout,upto)?parse.tree:null;return parse.updateViewport(oldVieport),result}class DocInput{constructor(doc){this.doc=doc,this.cursorPos=0,this.string="",this.cursor=doc.iter()}get length(){return this.doc.length}syncTo(pos){return this.string=this.cursor.next(pos-this.cursorPos).value,this.cursorPos=pos+this.string.length,this.cursorPos-this.string.length}chunk(pos){return this.syncTo(pos),this.string}get lineChunks(){return!0}read(from,to){let stringStart=this.cursorPos-this.string.length;return from<stringStart||to>=this.cursorPos?this.doc.sliceString(from,to):this.string.slice(from-stringStart,to-stringStart)}}let currentContext=null;class ParseContext{constructor(parser,state,fragments=[],tree,treeLen,viewport,skipped,scheduleOn){this.parser=parser,this.state=state,this.fragments=fragments,this.tree=tree,this.treeLen=treeLen,this.viewport=viewport,this.skipped=skipped,this.scheduleOn=scheduleOn,this.parse=null,this.tempSkipped=[]}static create(parser,state,viewport){return new ParseContext(parser,state,[],common.Tree.empty,0,viewport,[],null)}startParse(){return this.parser.startParse(new DocInput(this.state.doc),this.fragments)}work(until,upto){return null!=upto&&upto>=this.state.doc.length&&(upto=void 0),this.tree!=common.Tree.empty&&this.isDone(null!=upto?upto:this.state.doc.length)?(this.takeTree(),!0):this.withContext((()=>{var _a;if("number"==typeof until){let endTime=Date.now()+until;until=()=>Date.now()>endTime}for(this.parse||(this.parse=this.startParse()),null!=upto&&(null==this.parse.stoppedAt||this.parse.stoppedAt>upto)&&upto<this.state.doc.length&&this.parse.stopAt(upto);;){let done=this.parse.advance();if(done){if(this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(done,this.fragments,null!=this.parse.stoppedAt)),this.treeLen=null!==(_a=this.parse.stoppedAt)&&void 0!==_a?_a:this.state.doc.length,this.tree=done,this.parse=null,!(this.treeLen<(null!=upto?upto:this.state.doc.length)))return!0;this.parse=this.startParse()}if(until())return!1}}))}takeTree(){let pos,tree;this.parse&&(pos=this.parse.parsedPos)>=this.treeLen&&((null==this.parse.stoppedAt||this.parse.stoppedAt>pos)&&this.parse.stopAt(pos),this.withContext((()=>{for(;!(tree=this.parse.advance()););})),this.treeLen=pos,this.tree=tree,this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(this.tree,this.fragments,!0)),this.parse=null)}withContext(f){let prev=currentContext;currentContext=this;try{return f()}finally{currentContext=prev}}withoutTempSkipped(fragments){for(let r;r=this.tempSkipped.pop();)fragments=cutFragments(fragments,r.from,r.to);return fragments}changes(changes,newState){let{fragments:fragments,tree:tree,treeLen:treeLen,viewport:viewport,skipped:skipped}=this;if(this.takeTree(),!changes.empty){let ranges=[];if(changes.iterChangedRanges(((fromA,toA,fromB,toB)=>ranges.push({fromA:fromA,toA:toA,fromB:fromB,toB:toB}))),fragments=common.TreeFragment.applyChanges(fragments,ranges),tree=common.Tree.empty,treeLen=0,viewport={from:changes.mapPos(viewport.from,-1),to:changes.mapPos(viewport.to,1)},this.skipped.length){skipped=[];for(let r of this.skipped){let from=changes.mapPos(r.from,1),to=changes.mapPos(r.to,-1);from<to&&skipped.push({from:from,to:to})}}}return new ParseContext(this.parser,newState,fragments,tree,treeLen,viewport,skipped,this.scheduleOn)}updateViewport(viewport){if(this.viewport.from==viewport.from&&this.viewport.to==viewport.to)return!1;this.viewport=viewport;let startLen=this.skipped.length;for(let i=0;i<this.skipped.length;i++){let{from:from,to:to}=this.skipped[i];from<viewport.to&&to>viewport.from&&(this.fragments=cutFragments(this.fragments,from,to),this.skipped.splice(i--,1))}return!(this.skipped.length>=startLen)&&(this.reset(),!0)}reset(){this.parse&&(this.takeTree(),this.parse=null)}skipUntilInView(from,to){this.skipped.push({from:from,to:to})}static getSkippingParser(until){return new class extends common.Parser{createParse(input,fragments,ranges){let from=ranges[0].from,to=ranges[ranges.length-1].to;return{parsedPos:from,advance(){let cx=currentContext;if(cx){for(let r of ranges)cx.tempSkipped.push(r);until&&(cx.scheduleOn=cx.scheduleOn?Promise.all([cx.scheduleOn,until]):until)}return this.parsedPos=to,new common.Tree(common.NodeType.none,[],[],to-from)},stoppedAt:null,stopAt(){}}}}}isDone(upto){upto=Math.min(upto,this.state.doc.length);let frags=this.fragments;return this.treeLen>=upto&&frags.length&&0==frags[0].from&&frags[0].to>=upto}static get(){return currentContext}}function cutFragments(fragments,from,to){return common.TreeFragment.applyChanges(fragments,[{fromA:from,toA:to,fromB:from,toB:to}])}class LanguageState{constructor(context){this.context=context,this.tree=context.tree}apply(tr){if(!tr.docChanged&&this.tree==this.context.tree)return this;let newCx=this.context.changes(tr.changes,tr.state),upto=this.context.treeLen==tr.startState.doc.length?void 0:Math.max(tr.changes.mapPos(this.context.treeLen),newCx.viewport.to);return newCx.work(20,upto)||newCx.takeTree(),new LanguageState(newCx)}static init(state){let vpTo=Math.min(3e3,state.doc.length),parseState=ParseContext.create(state.facet(language).parser,state,{from:0,to:vpTo});return parseState.work(20,vpTo)||parseState.takeTree(),new LanguageState(parseState)}}Language.state=state.StateField.define({create:LanguageState.init,update(value,tr){for(let e of tr.effects)if(e.is(Language.setState))return e.value;return tr.startState.facet(language)!=tr.state.facet(language)?LanguageState.init(tr.state):value.apply(tr)}});let requestIdle=callback=>{let timeout=setTimeout((()=>callback()),500);return()=>clearTimeout(timeout)};"undefined"!=typeof requestIdleCallback&&(requestIdle=callback=>{let idle=-1,timeout=setTimeout((()=>{idle=requestIdleCallback(callback,{timeout:400})}),100);return()=>idle<0?clearTimeout(timeout):cancelIdleCallback(idle)});const isInputPending="undefined"!=typeof navigator&&(null===(_a=navigator.scheduling)||void 0===_a?void 0:_a.isInputPending)?()=>navigator.scheduling.isInputPending():null,parseWorker=view.ViewPlugin.fromClass(class{constructor(view){this.view=view,this.working=null,this.workScheduled=0,this.chunkEnd=-1,this.chunkBudget=-1,this.work=this.work.bind(this),this.scheduleWork()}update(update){let cx=this.view.state.field(Language.state).context;(cx.updateViewport(update.view.viewport)||this.view.viewport.to>cx.treeLen)&&this.scheduleWork(),(update.docChanged||update.selectionSet)&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork()),this.checkAsyncSchedule(cx)}scheduleWork(){if(this.working)return;let{state:state}=this.view,field=state.field(Language.state);field.tree==field.context.tree&&field.context.isDone(state.doc.length)||(this.working=requestIdle(this.work))}work(deadline){this.working=null;let now=Date.now();if(this.chunkEnd<now&&(this.chunkEnd<0||this.view.hasFocus)&&(this.chunkEnd=now+3e4,this.chunkBudget=3e3),this.chunkBudget<=0)return;let{state:state,viewport:{to:vpTo}}=this.view,field=state.field(Language.state);if(field.tree==field.context.tree&&field.context.isDone(vpTo+1e5))return;let endTime=Date.now()+Math.min(this.chunkBudget,100,deadline&&!isInputPending?Math.max(25,deadline.timeRemaining()-5):1e9),viewportFirst=field.context.treeLen<vpTo&&state.doc.length>vpTo+1e3,done=field.context.work((()=>isInputPending&&isInputPending()||Date.now()>endTime),vpTo+(viewportFirst?0:1e5));this.chunkBudget-=Date.now()-now,(done||this.chunkBudget<=0)&&(field.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(field.context))})),this.chunkBudget>0&&(!done||viewportFirst)&&this.scheduleWork(),this.checkAsyncSchedule(field.context)}checkAsyncSchedule(cx){cx.scheduleOn&&(this.workScheduled++,cx.scheduleOn.then((()=>this.scheduleWork())).catch((err=>view.logException(this.view.state,err))).then((()=>this.workScheduled--)),cx.scheduleOn=null)}destroy(){this.working&&this.working()}isWorking(){return!!(this.working||this.workScheduled>0)}},{eventHandlers:{focus(){this.scheduleWork()}}}),language=state.Facet.define({combine:languages=>languages.length?languages[0]:null,enables:language=>[Language.state,parseWorker,view.EditorView.contentAttributes.compute([language],(state=>{let lang=state.facet(language);return lang&&lang.name?{"data-language":lang.name}:{}}))]});class LanguageDescription{constructor(name,alias,extensions,filename,loadFunc,support=void 0){this.name=name,this.alias=alias,this.extensions=extensions,this.filename=filename,this.loadFunc=loadFunc,this.support=support,this.loading=null}load(){return this.loading||(this.loading=this.loadFunc().then((support=>this.support=support),(err=>{throw this.loading=null,err})))}static of(spec){let{load:load,support:support}=spec;if(!load){if(!support)throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");load=()=>Promise.resolve(support)}return new LanguageDescription(spec.name,(spec.alias||[]).concat(spec.name).map((s=>s.toLowerCase())),spec.extensions||[],spec.filename,load,support)}static matchFilename(descs,filename){for(let d of descs)if(d.filename&&d.filename.test(filename))return d;let ext=/\.([^.]+)$/.exec(filename);if(ext)for(let d of descs)if(d.extensions.indexOf(ext[1])>-1)return d;return null}static matchLanguageName(descs,name,fuzzy=!0){name=name.toLowerCase();for(let d of descs)if(d.alias.some((a=>a==name)))return d;if(fuzzy)for(let d of descs)for(let a of d.alias){let found=name.indexOf(a);if(found>-1&&(a.length>2||!/\w/.test(name[found-1])&&!/\w/.test(name[found+a.length])))return d}return null}}const indentService=state.Facet.define(),indentUnit=state.Facet.define({combine:values=>{if(!values.length)return"  ";let unit=values[0];if(!unit||/\S/.test(unit)||Array.from(unit).some((e=>e!=unit[0])))throw new Error("Invalid indent unit: "+JSON.stringify(values[0]));return unit}});function getIndentUnit(state){let unit=state.facet(indentUnit);return 9==unit.charCodeAt(0)?state.tabSize*unit.length:unit.length}function indentString(state,cols){let result="",ts=state.tabSize,ch=state.facet(indentUnit)[0];if("\t"==ch){for(;cols>=ts;)result+="\t",cols-=ts;ch=" "}for(let i=0;i<cols;i++)result+=ch;return result}function getIndentation(context,pos){context instanceof state.EditorState&&(context=new IndentContext(context));for(let service of context.state.facet(indentService)){let result=service(context,pos);if(void 0!==result)return result}let tree=syntaxTree(context.state);return tree.length>=pos?function(cx,ast,pos){let stack=ast.resolveStack(pos),inner=stack.node.enterUnfinishedNodesBefore(pos);if(inner!=stack.node){let add=[];for(let cur=inner;cur!=stack.node;cur=cur.parent)add.push(cur);for(let i=add.length-1;i>=0;i--)stack={node:add[i],next:stack}}return indentFor(stack,cx,pos)}(context,tree,pos):null}class IndentContext{constructor(state,options={}){this.state=state,this.options=options,this.unit=getIndentUnit(state)}lineAt(pos,bias=1){let line=this.state.doc.lineAt(pos),{simulateBreak:simulateBreak,simulateDoubleBreak:simulateDoubleBreak}=this.options;return null!=simulateBreak&&simulateBreak>=line.from&&simulateBreak<=line.to?simulateDoubleBreak&&simulateBreak==pos?{text:"",from:pos}:(bias<0?simulateBreak<pos:simulateBreak<=pos)?{text:line.text.slice(simulateBreak-line.from),from:simulateBreak}:{text:line.text.slice(0,simulateBreak-line.from),from:line.from}:line}textAfterPos(pos,bias=1){if(this.options.simulateDoubleBreak&&pos==this.options.simulateBreak)return"";let{text:text,from:from}=this.lineAt(pos,bias);return text.slice(pos-from,Math.min(text.length,pos+100-from))}column(pos,bias=1){let{text:text,from:from}=this.lineAt(pos,bias),result=this.countColumn(text,pos-from),override=this.options.overrideIndentation?this.options.overrideIndentation(from):-1;return override>-1&&(result+=override-this.countColumn(text,text.search(/\S|$/))),result}countColumn(line,pos=line.length){return state.countColumn(line,this.state.tabSize,pos)}lineIndent(pos,bias=1){let{text:text,from:from}=this.lineAt(pos,bias),override=this.options.overrideIndentation;if(override){let overriden=override(from);if(overriden>-1)return overriden}return this.countColumn(text,text.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}}const indentNodeProp=new common.NodeProp;function indentFor(stack,cx,pos){for(let cur=stack;cur;cur=cur.next){let strategy=indentStrategy(cur.node);if(strategy)return strategy(TreeIndentContext.create(cx,pos,cur))}return 0}function indentStrategy(tree){let strategy=tree.type.prop(indentNodeProp);if(strategy)return strategy;let close,first=tree.firstChild;if(first&&(close=first.type.prop(common.NodeProp.closedBy))){let last=tree.lastChild,closed=last&&close.indexOf(last.name)>-1;return cx=>delimitedStrategy(cx,!0,1,void 0,closed&&!function(cx){return cx.pos==cx.options.simulateBreak&&cx.options.simulateDoubleBreak}(cx)?last.from:void 0)}return null==tree.parent?topIndent:null}function topIndent(){return 0}class TreeIndentContext extends IndentContext{constructor(base,pos,context){super(base.state,base.options),this.base=base,this.pos=pos,this.context=context}get node(){return this.context.node}static create(base,pos,context){return new TreeIndentContext(base,pos,context)}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){return this.baseIndentFor(this.node)}baseIndentFor(node){let line=this.state.doc.lineAt(node.from);for(;;){let atBreak=node.resolve(line.from);for(;atBreak.parent&&atBreak.parent.from==atBreak.from;)atBreak=atBreak.parent;if(isParent(atBreak,node))break;line=this.state.doc.lineAt(atBreak.from)}return this.lineIndent(line.from)}continue(){return indentFor(this.context.next,this.base,this.pos)}}function isParent(parent,of){for(let cur=of;cur;cur=cur.parent)if(parent==cur)return!0;return!1}function delimitedStrategy(context,align,units,closing,closedAt){let after=context.textAfter,space=after.match(/^\s*/)[0].length,closed=closing&&after.slice(space,space+closing.length)==closing||closedAt==context.pos+space,aligned=align?function(context){let tree=context.node,openToken=tree.childAfter(tree.from),last=tree.lastChild;if(!openToken)return null;let sim=context.options.simulateBreak,openLine=context.state.doc.lineAt(openToken.from),lineEnd=null==sim||sim<=openLine.from?openLine.to:Math.min(openLine.to,sim);for(let pos=openToken.to;;){let next=tree.childAfter(pos);if(!next||next==last)return null;if(!next.type.isSkipped){if(next.from>=lineEnd)return null;let space=/^ */.exec(openLine.text.slice(openToken.to-openLine.from))[0].length;return{from:openToken.from,to:openToken.to+space}}pos=next.to}}(context):null;return aligned?closed?context.column(aligned.from):context.column(aligned.to):context.baseIndent+(closed?0:context.unit*units)}const foldService=state.Facet.define(),foldNodeProp=new common.NodeProp;function isUnfinished(node){let ch=node.lastChild;return ch&&ch.to==node.to&&ch.type.isError}function foldable(state,lineStart,lineEnd){for(let service of state.facet(foldService)){let result=service(state,lineStart,lineEnd);if(result)return result}return function(state,start,end){let tree=syntaxTree(state);if(tree.length<end)return null;let found=null;for(let iter=tree.resolveStack(end,1);iter;iter=iter.next){let cur=iter.node;if(cur.to<=end||cur.from>end)continue;if(found&&cur.from<start)break;let prop=cur.type.prop(foldNodeProp);if(prop&&(cur.to<tree.length-50||tree.length==state.doc.length||!isUnfinished(cur))){let value=prop(cur,state);value&&value.from<=end&&value.from>=start&&value.to>end&&(found=value)}}return found}(state,lineStart,lineEnd)}function mapRange(range,mapping){let from=mapping.mapPos(range.from,1),to=mapping.mapPos(range.to,-1);return from>=to?void 0:{from:from,to:to}}const foldEffect=state.StateEffect.define({map:mapRange}),unfoldEffect=state.StateEffect.define({map:mapRange});function selectedLines(view){let lines=[];for(let{head:head}of view.state.selection.ranges)lines.some((l=>l.from<=head&&l.to>=head))||lines.push(view.lineBlockAt(head));return lines}const foldState=state.StateField.define({create:()=>view.Decoration.none,update(folded,tr){folded=folded.map(tr.changes);for(let e of tr.effects)if(e.is(foldEffect)&&!foldExists(folded,e.value.from,e.value.to)){let{preparePlaceholder:preparePlaceholder}=tr.state.facet(foldConfig),widget=preparePlaceholder?view.Decoration.replace({widget:new PreparedFoldWidget(preparePlaceholder(tr.state,e.value))}):foldWidget;folded=folded.update({add:[widget.range(e.value.from,e.value.to)]})}else e.is(unfoldEffect)&&(folded=folded.update({filter:(from,to)=>e.value.from!=from||e.value.to!=to,filterFrom:e.value.from,filterTo:e.value.to}));if(tr.selection){let onSelection=!1,{head:head}=tr.selection.main;folded.between(head,head,((a,b)=>{a<head&&b>head&&(onSelection=!0)})),onSelection&&(folded=folded.update({filterFrom:head,filterTo:head,filter:(a,b)=>b<=head||a>=head}))}return folded},provide:f=>view.EditorView.decorations.from(f),toJSON(folded,state){let ranges=[];return folded.between(0,state.doc.length,((from,to)=>{ranges.push(from,to)})),ranges},fromJSON(value){if(!Array.isArray(value)||value.length%2)throw new RangeError("Invalid JSON for fold state");let ranges=[];for(let i=0;i<value.length;){let from=value[i++],to=value[i++];if("number"!=typeof from||"number"!=typeof to)throw new RangeError("Invalid JSON for fold state");ranges.push(foldWidget.range(from,to))}return view.Decoration.set(ranges,!0)}});function findFold(state,from,to){var _a;let found=null;return null===(_a=state.field(foldState,!1))||void 0===_a||_a.between(from,to,((from,to)=>{(!found||found.from>from)&&(found={from:from,to:to})})),found}function foldExists(folded,from,to){let found=!1;return folded.between(from,from,((a,b)=>{a==from&&b==to&&(found=!0)})),found}function maybeEnable(state$1,other){return state$1.field(foldState,!1)?other:other.concat(state.StateEffect.appendConfig.of(codeFolding()))}const foldCode=view=>{for(let line of selectedLines(view)){let range=foldable(view.state,line.from,line.to);if(range)return view.dispatch({effects:maybeEnable(view.state,[foldEffect.of(range),announceFold(view,range)])}),!0}return!1},unfoldCode=view=>{if(!view.state.field(foldState,!1))return!1;let effects=[];for(let line of selectedLines(view)){let folded=findFold(view.state,line.from,line.to);folded&&effects.push(unfoldEffect.of(folded),announceFold(view,folded,!1))}return effects.length&&view.dispatch({effects:effects}),effects.length>0};function announceFold(view$1,range,fold=!0){let lineFrom=view$1.state.doc.lineAt(range.from).number,lineTo=view$1.state.doc.lineAt(range.to).number;return view.EditorView.announce.of(`${view$1.state.phrase(fold?"Folded lines":"Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${lineTo}.`)}const foldAll=view=>{let{state:state}=view,effects=[];for(let pos=0;pos<state.doc.length;){let line=view.lineBlockAt(pos),range=foldable(state,line.from,line.to);range&&effects.push(foldEffect.of(range)),pos=(range?view.lineBlockAt(range.to):line).to+1}return effects.length&&view.dispatch({effects:maybeEnable(view.state,effects)}),!!effects.length},unfoldAll=view=>{let field=view.state.field(foldState,!1);if(!field||!field.size)return!1;let effects=[];return field.between(0,view.state.doc.length,((from,to)=>{effects.push(unfoldEffect.of({from:from,to:to}))})),view.dispatch({effects:effects}),!0};function foldableContainer(view,lineBlock){for(let line=lineBlock;;){let foldableRegion=foldable(view.state,line.from,line.to);if(foldableRegion&&foldableRegion.to>lineBlock.from)return foldableRegion;if(!line.from)return null;line=view.lineBlockAt(line.from-1)}}const foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:foldCode},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:unfoldCode},{key:"Ctrl-Alt-[",run:foldAll},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,preparePlaceholder:null,placeholderText:"…"},foldConfig=state.Facet.define({combine:values=>state.combineConfig(values,defaultConfig)});function codeFolding(config){let result=[foldState,baseTheme$1];return config&&result.push(foldConfig.of(config)),result}function widgetToDOM(view,prepared){let{state:state}=view,conf=state.facet(foldConfig),onclick=event=>{let line=view.lineBlockAt(view.posAtDOM(event.target)),folded=findFold(view.state,line.from,line.to);folded&&view.dispatch({effects:unfoldEffect.of(folded)}),event.preventDefault()};if(conf.placeholderDOM)return conf.placeholderDOM(view,onclick,prepared);let element=document.createElement("span");return element.textContent=conf.placeholderText,element.setAttribute("aria-label",state.phrase("folded code")),element.title=state.phrase("unfold"),element.className="cm-foldPlaceholder",element.onclick=onclick,element}const foldWidget=view.Decoration.replace({widget:new class extends view.WidgetType{toDOM(view){return widgetToDOM(view,null)}}});class PreparedFoldWidget extends view.WidgetType{constructor(value){super(),this.value=value}eq(other){return this.value==other.value}toDOM(view){return widgetToDOM(view,this.value)}}const foldGutterDefaults={openText:"⌄",closedText:"›",markerDOM:null,domEventHandlers:{},foldingChanged:()=>!1};class FoldMarker extends view.GutterMarker{constructor(config,open){super(),this.config=config,this.open=open}eq(other){return this.config==other.config&&this.open==other.open}toDOM(view){if(this.config.markerDOM)return this.config.markerDOM(this.open);let span=document.createElement("span");return span.textContent=this.open?this.config.openText:this.config.closedText,span.title=view.state.phrase(this.open?"Fold line":"Unfold line"),span}}const baseTheme$1=view.EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});class HighlightStyle{constructor(specs,options){let modSpec;function def(spec){let cls=styleMod.StyleModule.newName();return(modSpec||(modSpec=Object.create(null)))["."+cls]=spec,cls}this.specs=specs;const all="string"==typeof options.all?options.all:options.all?def(options.all):void 0,scopeOpt=options.scope;this.scope=scopeOpt instanceof Language?type=>type.prop(languageDataProp)==scopeOpt.data:scopeOpt?type=>type==scopeOpt:void 0,this.style=highlight.tagHighlighter(specs.map((style=>({tag:style.tag,class:style.class||def(Object.assign({},style,{tag:null}))}))),{all:all}).style,this.module=modSpec?new styleMod.StyleModule(modSpec):null,this.themeType=options.themeType}static define(specs,options){return new HighlightStyle(specs,options||{})}}const highlighterFacet=state.Facet.define(),fallbackHighlighter=state.Facet.define({combine:values=>values.length?[values[0]]:null});function getHighlighters(state){let main=state.facet(highlighterFacet);return main.length?main:state.facet(fallbackHighlighter)}const treeHighlighter=state.Prec.high(view.ViewPlugin.fromClass(class{constructor(view){this.markCache=Object.create(null),this.tree=syntaxTree(view.state),this.decorations=this.buildDeco(view,getHighlighters(view.state)),this.decoratedTo=view.viewport.to}update(update){let tree=syntaxTree(update.state),highlighters=getHighlighters(update.state),styleChange=highlighters!=getHighlighters(update.startState),{viewport:viewport}=update.view,decoratedToMapped=update.changes.mapPos(this.decoratedTo,1);tree.length<viewport.to&&!styleChange&&tree.type==this.tree.type&&decoratedToMapped>=viewport.to?(this.decorations=this.decorations.map(update.changes),this.decoratedTo=decoratedToMapped):(tree!=this.tree||update.viewportChanged||styleChange)&&(this.tree=tree,this.decorations=this.buildDeco(update.view,highlighters),this.decoratedTo=viewport.to)}buildDeco(view$1,highlighters){if(!highlighters||!this.tree.length)return view.Decoration.none;let builder=new state.RangeSetBuilder;for(let{from:from,to:to}of view$1.visibleRanges)highlight.highlightTree(this.tree,highlighters,((from,to,style)=>{builder.add(from,to,this.markCache[style]||(this.markCache[style]=view.Decoration.mark({class:style})))}),from,to);return builder.finish()}},{decorations:v=>v.decorations})),defaultHighlightStyle=HighlightStyle.define([{tag:highlight.tags.meta,color:"#404740"},{tag:highlight.tags.link,textDecoration:"underline"},{tag:highlight.tags.heading,textDecoration:"underline",fontWeight:"bold"},{tag:highlight.tags.emphasis,fontStyle:"italic"},{tag:highlight.tags.strong,fontWeight:"bold"},{tag:highlight.tags.strikethrough,textDecoration:"line-through"},{tag:highlight.tags.keyword,color:"#708"},{tag:[highlight.tags.atom,highlight.tags.bool,highlight.tags.url,highlight.tags.contentSeparator,highlight.tags.labelName],color:"#219"},{tag:[highlight.tags.literal,highlight.tags.inserted],color:"#164"},{tag:[highlight.tags.string,highlight.tags.deleted],color:"#a11"},{tag:[highlight.tags.regexp,highlight.tags.escape,highlight.tags.special(highlight.tags.string)],color:"#e40"},{tag:highlight.tags.definition(highlight.tags.variableName),color:"#00f"},{tag:highlight.tags.local(highlight.tags.variableName),color:"#30a"},{tag:[highlight.tags.typeName,highlight.tags.namespace],color:"#085"},{tag:highlight.tags.className,color:"#167"},{tag:[highlight.tags.special(highlight.tags.variableName),highlight.tags.macroName],color:"#256"},{tag:highlight.tags.definition(highlight.tags.propertyName),color:"#00c"},{tag:highlight.tags.comment,color:"#940"},{tag:highlight.tags.invalid,color:"#f00"}]),baseTheme=view.EditorView.baseTheme({"&.cm-focused .cm-matchingBracket":{backgroundColor:"#328c8252"},"&.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bb555544"}}),bracketMatchingConfig=state.Facet.define({combine:configs=>state.combineConfig(configs,{afterCursor:!0,brackets:"()[]{}",maxScanDistance:1e4,renderMatch:defaultRenderMatch})}),matchingMark=view.Decoration.mark({class:"cm-matchingBracket"}),nonmatchingMark=view.Decoration.mark({class:"cm-nonmatchingBracket"});function defaultRenderMatch(match){let decorations=[],mark=match.matched?matchingMark:nonmatchingMark;return decorations.push(mark.range(match.start.from,match.start.to)),match.end&&decorations.push(mark.range(match.end.from,match.end.to)),decorations}const bracketMatchingUnique=[state.StateField.define({create:()=>view.Decoration.none,update(deco,tr){if(!tr.docChanged&&!tr.selection)return deco;let decorations=[],config=tr.state.facet(bracketMatchingConfig);for(let range of tr.state.selection.ranges){if(!range.empty)continue;let match=matchBrackets(tr.state,range.head,-1,config)||range.head>0&&matchBrackets(tr.state,range.head-1,1,config)||config.afterCursor&&(matchBrackets(tr.state,range.head,1,config)||range.head<tr.state.doc.length&&matchBrackets(tr.state,range.head+1,-1,config));match&&(decorations=decorations.concat(config.renderMatch(match,tr.state)))}return view.Decoration.set(decorations,!0)},provide:f=>view.EditorView.decorations.from(f)}),baseTheme];const bracketMatchingHandle=new common.NodeProp;function matchingNodes(node,dir,brackets){let byProp=node.prop(dir<0?common.NodeProp.openedBy:common.NodeProp.closedBy);if(byProp)return byProp;if(1==node.name.length){let index=brackets.indexOf(node.name);if(index>-1&&index%2==(dir<0?1:0))return[brackets[index+dir]]}return null}function findHandle(node){let hasHandle=node.type.prop(bracketMatchingHandle);return hasHandle?hasHandle(node.node):node}function matchBrackets(state,pos,dir,config={}){let maxScanDistance=config.maxScanDistance||1e4,brackets=config.brackets||"()[]{}",tree=syntaxTree(state),node=tree.resolveInner(pos,dir);for(let cur=node;cur;cur=cur.parent){let matches=matchingNodes(cur.type,dir,brackets);if(matches&&cur.from<cur.to){let handle=findHandle(cur);if(handle&&(dir>0?pos>=handle.from&&pos<handle.to:pos>handle.from&&pos<=handle.to))return matchMarkedBrackets(state,pos,dir,cur,handle,matches,brackets)}}return function(state,pos,dir,tree,tokenType,maxScanDistance,brackets){let startCh=dir<0?state.sliceDoc(pos-1,pos):state.sliceDoc(pos,pos+1),bracket=brackets.indexOf(startCh);if(bracket<0||bracket%2==0!=dir>0)return null;let startToken={from:dir<0?pos-1:pos,to:dir>0?pos+1:pos},iter=state.doc.iterRange(pos,dir>0?state.doc.length:0),depth=0;for(let distance=0;!iter.next().done&&distance<=maxScanDistance;){let text=iter.value;dir<0&&(distance+=text.length);let basePos=pos+distance*dir;for(let pos=dir>0?0:text.length-1,end=dir>0?text.length:-1;pos!=end;pos+=dir){let found=brackets.indexOf(text[pos]);if(!(found<0||tree.resolveInner(basePos+pos,1).type!=tokenType))if(found%2==0==dir>0)depth++;else{if(1==depth)return{start:startToken,end:{from:basePos+pos,to:basePos+pos+1},matched:found>>1==bracket>>1};depth--}}dir>0&&(distance+=text.length)}return iter.done?{start:startToken,matched:!1}:null}(state,pos,dir,tree,node.type,maxScanDistance,brackets)}function matchMarkedBrackets(_state,_pos,dir,token,handle,matching,brackets){let parent=token.parent,firstToken={from:handle.from,to:handle.to},depth=0,cursor=null==parent?void 0:parent.cursor();if(cursor&&(dir<0?cursor.childBefore(token.from):cursor.childAfter(token.to)))do{if(dir<0?cursor.to<=token.from:cursor.from>=token.to){if(0==depth&&matching.indexOf(cursor.type.name)>-1&&cursor.from<cursor.to){let endHandle=findHandle(cursor);return{start:firstToken,end:endHandle?{from:endHandle.from,to:endHandle.to}:void 0,matched:!0}}if(matchingNodes(cursor.type,dir,brackets))depth++;else if(matchingNodes(cursor.type,-dir,brackets)){if(0==depth){let endHandle=findHandle(cursor);return{start:firstToken,end:endHandle&&endHandle.from<endHandle.to?{from:endHandle.from,to:endHandle.to}:void 0,matched:!1}}depth--}}}while(dir<0?cursor.prevSibling():cursor.nextSibling());return{start:firstToken,matched:!1}}function countCol(string,end,tabSize,startIndex=0,startValue=0){null==end&&-1==(end=string.search(/[^\s\u00a0]/))&&(end=string.length);let n=startValue;for(let i=startIndex;i<end;i++)9==string.charCodeAt(i)?n+=tabSize-n%tabSize:n++;return n}class StringStream{constructor(string,tabSize,indentUnit,overrideIndent){this.string=string,this.tabSize=tabSize,this.indentUnit=indentUnit,this.overrideIndent=overrideIndent,this.pos=0,this.start=0,this.lastColumnPos=0,this.lastColumnValue=0}eol(){return this.pos>=this.string.length}sol(){return 0==this.pos}peek(){return this.string.charAt(this.pos)||void 0}next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}eat(match){let ok,ch=this.string.charAt(this.pos);if(ok="string"==typeof match?ch==match:ch&&(match instanceof RegExp?match.test(ch):match(ch)),ok)return++this.pos,ch}eatWhile(match){let start=this.pos;for(;this.eat(match););return this.pos>start}eatSpace(){let start=this.pos;for(;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>start}skipToEnd(){this.pos=this.string.length}skipTo(ch){let found=this.string.indexOf(ch,this.pos);if(found>-1)return this.pos=found,!0}backUp(n){this.pos-=n}column(){return this.lastColumnPos<this.start&&(this.lastColumnValue=countCol(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue}indentation(){var _a;return null!==(_a=this.overrideIndent)&&void 0!==_a?_a:countCol(this.string,null,this.tabSize)}match(pattern,consume,caseInsensitive){if("string"==typeof pattern){let cased=str=>caseInsensitive?str.toLowerCase():str;return cased(this.string.substr(this.pos,pattern.length))==cased(pattern)?(!1!==consume&&(this.pos+=pattern.length),!0):null}{let match=this.string.slice(this.pos).match(pattern);return match&&match.index>0?null:(match&&!1!==consume&&(this.pos+=match[0].length),match)}}current(){return this.string.slice(this.start,this.pos)}}function defaultCopyState(state){if("object"!=typeof state)return state;let newState={};for(let prop in state){let val=state[prop];newState[prop]=val instanceof Array?val.slice():val}return newState}const IndentedFrom=new WeakMap;class StreamLanguage extends Language{constructor(parser){let self,data=defineLanguageFacet(parser.languageData),p={name:(spec=parser).name||"",token:spec.token,blankLine:spec.blankLine||(()=>{}),startState:spec.startState||(()=>!0),copyState:spec.copyState||defaultCopyState,indent:spec.indent||(()=>null),languageData:spec.languageData||{},tokenTable:spec.tokenTable||noTokens};var spec;super(data,new class extends common.Parser{createParse(input,fragments,ranges){return new Parse(self,input,fragments,ranges)}},[indentService.of(((cx,pos)=>this.getIndent(cx,pos)))],parser.name),this.topNode=function(data){let type=common.NodeType.define({id:typeArray.length,name:"Document",props:[languageDataProp.add((()=>data))],top:!0});return typeArray.push(type),type}(data),self=this,this.streamParser=p,this.stateAfter=new common.NodeProp({perNode:!0}),this.tokenTable=parser.tokenTable?new TokenTable(p.tokenTable):defaultTokenTable}static define(spec){return new StreamLanguage(spec)}getIndent(cx,pos){let from,tree=syntaxTree(cx.state),at=tree.resolve(pos);for(;at&&at.type!=this.topNode;)at=at.parent;if(!at)return null;let{overrideIndentation:overrideIndentation}=cx.options;overrideIndentation&&(from=IndentedFrom.get(cx.state),null!=from&&from<pos-1e4&&(from=void 0));let statePos,state,start=findState(this,tree,0,at.from,null!=from?from:pos);if(start?(state=start.state,statePos=start.pos+1):(state=this.streamParser.startState(cx.unit),statePos=0),pos-statePos>1e4)return null;for(;statePos<pos;){let line=cx.state.doc.lineAt(statePos),end=Math.min(pos,line.to);if(line.length){let indentation=overrideIndentation?overrideIndentation(line.from):-1,stream=new StringStream(line.text,cx.state.tabSize,cx.unit,indentation<0?void 0:indentation);for(;stream.pos<end-line.from;)readToken(this.streamParser.token,stream,state)}else this.streamParser.blankLine(state,cx.unit);if(end==pos)break;statePos=line.to+1}let line=cx.lineAt(pos);return overrideIndentation&&null==from&&IndentedFrom.set(cx.state,line.from),this.streamParser.indent(state,/^\s*(.*)/.exec(line.text)[1],cx)}get allowsNesting(){return!1}}function findState(lang,tree,off,startPos,before){let state=off>=startPos&&off+tree.length<=before&&tree.prop(lang.stateAfter);if(state)return{state:lang.streamParser.copyState(state),pos:off+tree.length};for(let i=tree.children.length-1;i>=0;i--){let child=tree.children[i],pos=off+tree.positions[i],found=child instanceof common.Tree&&pos<before&&findState(lang,child,pos,startPos,before);if(found)return found}return null}function cutTree(lang,tree,from,to,inside){if(inside&&from<=0&&to>=tree.length)return tree;inside||tree.type!=lang.topNode||(inside=!0);for(let i=tree.children.length-1;i>=0;i--){let inner,pos=tree.positions[i],child=tree.children[i];if(pos<to&&child instanceof common.Tree){if(!(inner=cutTree(lang,child,from-pos,to-pos,inside)))break;return inside?new common.Tree(tree.type,tree.children.slice(0,i).concat(inner),tree.positions.slice(0,i+1),pos+inner.length):inner}}return null}class Parse{constructor(lang,input,fragments,ranges){this.lang=lang,this.input=input,this.fragments=fragments,this.ranges=ranges,this.stoppedAt=null,this.chunks=[],this.chunkPos=[],this.chunk=[],this.chunkReused=void 0,this.rangeIndex=0,this.to=ranges[ranges.length-1].to;let context=ParseContext.get(),from=ranges[0].from,{state:state,tree:tree}=function(lang,fragments,startPos,editorState){for(let f of fragments){let tree,from=f.from+(f.openStart?25:0),to=f.to-(f.openEnd?25:0),found=from<=startPos&&to>startPos&&findState(lang,f.tree,0-f.offset,startPos,to);if(found&&(tree=cutTree(lang,f.tree,startPos+f.offset,found.pos+f.offset,!1)))return{state:found.state,tree:tree}}return{state:lang.streamParser.startState(editorState?getIndentUnit(editorState):4),tree:common.Tree.empty}}(lang,fragments,from,null==context?void 0:context.state);this.state=state,this.parsedPos=this.chunkStart=from+tree.length;for(let i=0;i<tree.children.length;i++)this.chunks.push(tree.children[i]),this.chunkPos.push(tree.positions[i]);context&&this.parsedPos<context.viewport.from-1e5&&(this.state=this.lang.streamParser.startState(getIndentUnit(context.state)),context.skipUntilInView(this.parsedPos,context.viewport.from),this.parsedPos=context.viewport.from),this.moveRangeIndex()}advance(){let context=ParseContext.get(),parseEnd=null==this.stoppedAt?this.to:Math.min(this.to,this.stoppedAt),end=Math.min(parseEnd,this.chunkStart+2048);for(context&&(end=Math.min(end,context.viewport.to));this.parsedPos<end;)this.parseLine(context);return this.chunkStart<this.parsedPos&&this.finishChunk(),this.parsedPos>=parseEnd?this.finish():context&&this.parsedPos>=context.viewport.to?(context.skipUntilInView(this.parsedPos,parseEnd),this.finish()):null}stopAt(pos){this.stoppedAt=pos}lineAfter(pos){let chunk=this.input.chunk(pos);if(this.input.lineChunks)"\n"==chunk&&(chunk="");else{let eol=chunk.indexOf("\n");eol>-1&&(chunk=chunk.slice(0,eol))}return pos+chunk.length<=this.to?chunk:chunk.slice(0,this.to-pos)}nextLine(){let from=this.parsedPos,line=this.lineAfter(from),end=from+line.length;for(let index=this.rangeIndex;;){let rangeEnd=this.ranges[index].to;if(rangeEnd>=end)break;if(line=line.slice(0,rangeEnd-(end-line.length)),index++,index==this.ranges.length)break;let rangeStart=this.ranges[index].from,after=this.lineAfter(rangeStart);line+=after,end=rangeStart+after.length}return{line:line,end:end}}skipGapsTo(pos,offset,side){for(;;){let end=this.ranges[this.rangeIndex].to,offPos=pos+offset;if(side>0?end>offPos:end>=offPos)break;offset+=this.ranges[++this.rangeIndex].from-end}return offset}moveRangeIndex(){for(;this.ranges[this.rangeIndex].to<this.parsedPos;)this.rangeIndex++}emitToken(id,from,to,size,offset){if(this.ranges.length>1){from+=offset=this.skipGapsTo(from,offset,1);let len0=this.chunk.length;to+=offset=this.skipGapsTo(to,offset,-1),size+=this.chunk.length-len0}return this.chunk.push(id,from,to,size),offset}parseLine(context){let{line:line,end:end}=this.nextLine(),offset=0,{streamParser:streamParser}=this.lang,stream=new StringStream(line,context?context.state.tabSize:4,context?getIndentUnit(context.state):2);if(stream.eol())streamParser.blankLine(this.state,stream.indentUnit);else for(;!stream.eol();){let token=readToken(streamParser.token,stream,this.state);if(token&&(offset=this.emitToken(this.lang.tokenTable.resolve(token),this.parsedPos+stream.start,this.parsedPos+stream.pos,4,offset)),stream.start>1e4)break}this.parsedPos=end,this.moveRangeIndex(),this.parsedPos<this.to&&this.parsedPos++}finishChunk(){let tree=common.Tree.build({buffer:this.chunk,start:this.chunkStart,length:this.parsedPos-this.chunkStart,nodeSet:nodeSet,topID:0,maxBufferLength:2048,reused:this.chunkReused});tree=new common.Tree(tree.type,tree.children,tree.positions,tree.length,[[this.lang.stateAfter,this.lang.streamParser.copyState(this.state)]]),this.chunks.push(tree),this.chunkPos.push(this.chunkStart-this.ranges[0].from),this.chunk=[],this.chunkReused=void 0,this.chunkStart=this.parsedPos}finish(){return new common.Tree(this.lang.topNode,this.chunks,this.chunkPos,this.parsedPos-this.ranges[0].from).balance()}}function readToken(token,stream,state){stream.start=stream.pos;for(let i=0;i<10;i++){let result=token(stream,state);if(stream.pos>stream.start)return result}throw new Error("Stream parser failed to advance stream.")}const noTokens=Object.create(null),typeArray=[common.NodeType.none],nodeSet=new common.NodeSet(typeArray),warned=[],byTag=Object.create(null),defaultTable=Object.create(null);for(let[legacyName,name]of[["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","tagName"],["attribute","attributeName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])defaultTable[legacyName]=createTokenType(noTokens,name);class TokenTable{constructor(extra){this.extra=extra,this.table=Object.assign(Object.create(null),defaultTable)}resolve(tag){return tag?this.table[tag]||(this.table[tag]=createTokenType(this.extra,tag)):0}}const defaultTokenTable=new TokenTable(noTokens);function warnForPart(part,msg){warned.indexOf(part)>-1||(warned.push(part),console.warn(msg))}function createTokenType(extra,tagStr){let tags=[];for(let name of tagStr.split(" ")){let found=[];for(let part of name.split(".")){let value=extra[part]||highlight.tags[part];value?"function"==typeof value?found.length?found=found.map(value):warnForPart(part,`Modifier ${part} used at start of tag`):found.length?warnForPart(part,`Tag ${part} used as modifier`):found=Array.isArray(value)?value:[value]:warnForPart(part,`Unknown highlighting tag ${part}`)}for(let tag of found)tags.push(tag)}if(!tags.length)return 0;let name=tagStr.replace(/ /g,"_"),key=name+" "+tags.map((t=>t.id)),known=byTag[key];if(known)return known.id;let type=byTag[key]=common.NodeType.define({id:typeArray.length,name:name,props:[highlight.styleTags({[name]:tags})]});return typeArray.push(type),type.id}function buildForLine(line){return line.length<=4096&&/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line)}function textHasRTL(text){for(let i=text.iter();!i.next().done;)if(buildForLine(i.value))return!0;return!1}const alwaysIsolate=state.Facet.define({combine:values=>values.some((x=>x))});const isolateMarks=view.ViewPlugin.fromClass(class{constructor(view$1){this.always=view$1.state.facet(alwaysIsolate)||view$1.textDirection!=view.Direction.LTR||view$1.state.facet(view.EditorView.perLineTextDirection),this.hasRTL=!this.always&&textHasRTL(view$1.state.doc),this.tree=syntaxTree(view$1.state),this.decorations=this.always||this.hasRTL?buildDeco(view$1,this.tree,this.always):view.Decoration.none}update(update){let always=update.state.facet(alwaysIsolate)||update.view.textDirection!=view.Direction.LTR||update.state.facet(view.EditorView.perLineTextDirection);if(always||this.hasRTL||!function(change){let added=!1;return change.iterChanges(((fA,tA,fB,tB,ins)=>{!added&&textHasRTL(ins)&&(added=!0)})),added}(update.changes)||(this.hasRTL=!0),!always&&!this.hasRTL)return;let tree=syntaxTree(update.state);(always!=this.always||tree!=this.tree||update.docChanged||update.viewportChanged)&&(this.tree=tree,this.always=always,this.decorations=buildDeco(update.view,tree,always))}},{provide:plugin=>{function access(view$1){var _a,_b;return null!==(_b=null===(_a=view$1.plugin(plugin))||void 0===_a?void 0:_a.decorations)&&void 0!==_b?_b:view.Decoration.none}return[view.EditorView.outerDecorations.of(access),state.Prec.lowest(view.EditorView.bidiIsolatedRanges.of(access))]}});function buildDeco(view,tree,always){let deco=new state.RangeSetBuilder,ranges=view.visibleRanges;always||(ranges=function(ranges,doc){let cur=doc.iter(),pos=0,result=[],last=null;for(let{from:from,to:to}of ranges)if(!(last&&last.to>from&&(from=last.to,from>=to)))for(pos+cur.value.length<from&&(cur.next(from-(pos+cur.value.length)),pos=from);;){let start=pos,end=pos+cur.value.length;if(!cur.lineBreak&&buildForLine(cur.value)&&(last&&last.to>start-10?last.to=Math.min(to,end):result.push(last={from:start,to:Math.min(to,end)})),end>=to)break;pos=end,cur.next()}return result}(ranges,view.state.doc));for(let{from:from,to:to}of ranges)tree.iterate({enter:node=>{let iso=node.type.prop(common.NodeProp.isolate);iso&&deco.add(node.from,node.to,marks[iso])},from:from,to:to});return deco.finish()}const marks={rtl:view.Decoration.mark({class:"cm-iso",inclusive:!0,attributes:{dir:"rtl"},bidiIsolate:view.Direction.RTL}),ltr:view.Decoration.mark({class:"cm-iso",inclusive:!0,attributes:{dir:"ltr"},bidiIsolate:view.Direction.LTR}),auto:view.Decoration.mark({class:"cm-iso",inclusive:!0,attributes:{dir:"auto"},bidiIsolate:null})};return dist$2.DocInput=DocInput,dist$2.HighlightStyle=HighlightStyle,dist$2.IndentContext=IndentContext,dist$2.LRLanguage=LRLanguage,dist$2.Language=Language,dist$2.LanguageDescription=LanguageDescription,dist$2.LanguageSupport=class{constructor(language,support=[]){this.language=language,this.support=support,this.extension=[language,support]}},dist$2.ParseContext=ParseContext,dist$2.StreamLanguage=StreamLanguage,dist$2.StringStream=StringStream,dist$2.TreeIndentContext=TreeIndentContext,dist$2.bidiIsolates=function(options={}){let extensions=[isolateMarks];return options.alwaysIsolate&&extensions.push(alwaysIsolate.of(!0)),extensions},dist$2.bracketMatching=function(config={}){return[bracketMatchingConfig.of(config),bracketMatchingUnique]},dist$2.bracketMatchingHandle=bracketMatchingHandle,dist$2.codeFolding=codeFolding,dist$2.continuedIndent=function({except:except,units:units=1}={}){return context=>{let matchExcept=except&&except.test(context.textAfter);return context.baseIndent+(matchExcept?0:units*context.unit)}},dist$2.defaultHighlightStyle=defaultHighlightStyle,dist$2.defineLanguageFacet=defineLanguageFacet,dist$2.delimitedIndent=function({closing:closing,align:align=!0,units:units=1}){return context=>delimitedStrategy(context,align,units,closing)},dist$2.ensureSyntaxTree=ensureSyntaxTree,dist$2.flatIndent=context=>context.baseIndent,dist$2.foldAll=foldAll,dist$2.foldCode=foldCode,dist$2.foldEffect=foldEffect,dist$2.foldGutter=function(config={}){let fullConfig=Object.assign(Object.assign({},foldGutterDefaults),config),canFold=new FoldMarker(fullConfig,!0),canUnfold=new FoldMarker(fullConfig,!1),markers=view.ViewPlugin.fromClass(class{constructor(view){this.from=view.viewport.from,this.markers=this.buildMarkers(view)}update(update){(update.docChanged||update.viewportChanged||update.startState.facet(language)!=update.state.facet(language)||update.startState.field(foldState,!1)!=update.state.field(foldState,!1)||syntaxTree(update.startState)!=syntaxTree(update.state)||fullConfig.foldingChanged(update))&&(this.markers=this.buildMarkers(update.view))}buildMarkers(view){let builder=new state.RangeSetBuilder;for(let line of view.viewportLineBlocks){let mark=findFold(view.state,line.from,line.to)?canUnfold:foldable(view.state,line.from,line.to)?canFold:null;mark&&builder.add(line.from,line.from,mark)}return builder.finish()}}),{domEventHandlers:domEventHandlers}=fullConfig;return[markers,view.gutter({class:"cm-foldGutter",markers(view){var _a;return(null===(_a=view.plugin(markers))||void 0===_a?void 0:_a.markers)||state.RangeSet.empty},initialSpacer:()=>new FoldMarker(fullConfig,!1),domEventHandlers:Object.assign(Object.assign({},domEventHandlers),{click:(view,line,event)=>{if(domEventHandlers.click&&domEventHandlers.click(view,line,event))return!0;let folded=findFold(view.state,line.from,line.to);if(folded)return view.dispatch({effects:unfoldEffect.of(folded)}),!0;let range=foldable(view.state,line.from,line.to);return!!range&&(view.dispatch({effects:foldEffect.of(range)}),!0)}})}),codeFolding()]},dist$2.foldInside=function(node){let first=node.firstChild,last=node.lastChild;return first&&first.to<last.from?{from:first.to,to:last.type.isError?node.to:last.from}:null},dist$2.foldKeymap=foldKeymap,dist$2.foldNodeProp=foldNodeProp,dist$2.foldService=foldService,dist$2.foldState=foldState,dist$2.foldable=foldable,dist$2.foldedRanges=function(state$1){return state$1.field(foldState,!1)||state.RangeSet.empty},dist$2.forceParsing=function(view,upto=view.viewport.to,timeout=100){let success=ensureSyntaxTree(view.state,upto,timeout);return success!=syntaxTree(view.state)&&view.dispatch({}),!!success},dist$2.getIndentUnit=getIndentUnit,dist$2.getIndentation=getIndentation,dist$2.highlightingFor=function(state,tags,scope){let highlighters=getHighlighters(state),result=null;if(highlighters)for(let highlighter of highlighters)if(!highlighter.scope||scope&&highlighter.scope(scope)){let cls=highlighter.style(tags);cls&&(result=result?result+" "+cls:cls)}return result},dist$2.indentNodeProp=indentNodeProp,dist$2.indentOnInput=function(){return state.EditorState.transactionFilter.of((tr=>{if(!tr.docChanged||!tr.isUserEvent("input.type")&&!tr.isUserEvent("input.complete"))return tr;let rules=tr.startState.languageDataAt("indentOnInput",tr.startState.selection.main.head);if(!rules.length)return tr;let doc=tr.newDoc,{head:head}=tr.newSelection.main,line=doc.lineAt(head);if(head>line.from+200)return tr;let lineStart=doc.sliceString(line.from,head);if(!rules.some((r=>r.test(lineStart))))return tr;let{state:state}=tr,last=-1,changes=[];for(let{head:head}of state.selection.ranges){let line=state.doc.lineAt(head);if(line.from==last)continue;last=line.from;let indent=getIndentation(state,line.from);if(null==indent)continue;let cur=/^\s*/.exec(line.text)[0],norm=indentString(state,indent);cur!=norm&&changes.push({from:line.from,to:line.from+cur.length,insert:norm})}return changes.length?[tr,{changes:changes,sequential:!0}]:tr}))},dist$2.indentRange=function(state,from,to){let updated=Object.create(null),context=new IndentContext(state,{overrideIndentation:start=>{var _a;return null!==(_a=updated[start])&&void 0!==_a?_a:-1}}),changes=[];for(let pos=from;pos<=to;){let line=state.doc.lineAt(pos);pos=line.to+1;let indent=getIndentation(context,line.from);if(null==indent)continue;/\S/.test(line.text)||(indent=0);let cur=/^\s*/.exec(line.text)[0],norm=indentString(state,indent);cur!=norm&&(updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm}))}return state.changes(changes)},dist$2.indentService=indentService,dist$2.indentString=indentString,dist$2.indentUnit=indentUnit,dist$2.language=language,dist$2.languageDataProp=languageDataProp,dist$2.matchBrackets=matchBrackets,dist$2.sublanguageProp=sublanguageProp,dist$2.syntaxHighlighting=function(highlighter,options){let themeType,ext=[treeHighlighter];return highlighter instanceof HighlightStyle&&(highlighter.module&&ext.push(view.EditorView.styleModule.of(highlighter.module)),themeType=highlighter.themeType),(null==options?void 0:options.fallback)?ext.push(fallbackHighlighter.of(highlighter)):themeType?ext.push(highlighterFacet.computeN([view.EditorView.darkTheme],(state=>state.facet(view.EditorView.darkTheme)==("dark"==themeType)?[highlighter]:[]))):ext.push(highlighterFacet.of(highlighter)),ext},dist$2.syntaxParserRunning=function(view){var _a;return(null===(_a=view.plugin(parseWorker))||void 0===_a?void 0:_a.isWorking())||!1},dist$2.syntaxTree=syntaxTree,dist$2.syntaxTreeAvailable=function(state,upto=state.doc.length){var _a;return(null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context.isDone(upto))||!1},dist$2.toggleFold=view=>{let effects=[];for(let line of selectedLines(view)){let folded=findFold(view.state,line.from,line.to);if(folded)effects.push(unfoldEffect.of(folded),announceFold(view,folded,!1));else{let foldRange=foldableContainer(view,line);foldRange&&effects.push(foldEffect.of(foldRange),announceFold(view,foldRange))}}return effects.length>0&&view.dispatch({effects:maybeEnable(view.state,effects)}),!!effects.length},dist$2.unfoldAll=unfoldAll,dist$2.unfoldCode=unfoldCode,dist$2.unfoldEffect=unfoldEffect,dist$2}function requireDist(){if(hasRequiredDist)return dist$3;hasRequiredDist=1;var state=require$$0,view=require$$2,language=requireDist$1(),common=requireDist$3();const toggleComment=target=>{let{state:state}=target,line=state.doc.lineAt(state.selection.main.from),config=getConfig(target.state,line.from);return config.line?toggleLineComment(target):!!config.block&&toggleBlockCommentByLine(target)};function command(f,option){return({state:state,dispatch:dispatch})=>{if(state.readOnly)return!1;let tr=f(option,state);return!!tr&&(dispatch(state.update(tr)),!0)}}const toggleLineComment=command(changeLineComment,0),lineComment=command(changeLineComment,1),lineUncomment=command(changeLineComment,2),toggleBlockComment=command(changeBlockComment,0),blockComment=command(changeBlockComment,1),blockUncomment=command(changeBlockComment,2),toggleBlockCommentByLine=command(((o,s)=>changeBlockComment(o,s,function(state){let ranges=[];for(let r of state.selection.ranges){let fromLine=state.doc.lineAt(r.from),toLine=r.to<=fromLine.to?fromLine:state.doc.lineAt(r.to),last=ranges.length-1;last>=0&&ranges[last].to>fromLine.from?ranges[last].to=toLine.to:ranges.push({from:fromLine.from+/^\s*/.exec(fromLine.text)[0].length,to:toLine.to})}return ranges}(s))),0);function getConfig(state,pos){let data=state.languageDataAt("commentTokens",pos);return data.length?data[0]:{}}const SearchMargin=50;function changeBlockComment(option,state,ranges=state.selection.ranges){let tokens=ranges.map((r=>getConfig(state,r.from).block));if(!tokens.every((c=>c)))return null;let comments=ranges.map(((r,i)=>function(state,{open:open,close:close},from,to){let startText,endText,textBefore=state.sliceDoc(from-SearchMargin,from),textAfter=state.sliceDoc(to,to+SearchMargin),spaceBefore=/\s*$/.exec(textBefore)[0].length,spaceAfter=/^\s*/.exec(textAfter)[0].length,beforeOff=textBefore.length-spaceBefore;if(textBefore.slice(beforeOff-open.length,beforeOff)==open&&textAfter.slice(spaceAfter,spaceAfter+close.length)==close)return{open:{pos:from-spaceBefore,margin:spaceBefore&&1},close:{pos:to+spaceAfter,margin:spaceAfter&&1}};to-from<=2*SearchMargin?startText=endText=state.sliceDoc(from,to):(startText=state.sliceDoc(from,from+SearchMargin),endText=state.sliceDoc(to-SearchMargin,to));let startSpace=/^\s*/.exec(startText)[0].length,endSpace=/\s*$/.exec(endText)[0].length,endOff=endText.length-endSpace-close.length;return startText.slice(startSpace,startSpace+open.length)==open&&endText.slice(endOff,endOff+close.length)==close?{open:{pos:from+startSpace+open.length,margin:/\s/.test(startText.charAt(startSpace+open.length))?1:0},close:{pos:to-endSpace-close.length,margin:/\s/.test(endText.charAt(endOff-1))?1:0}}:null}(state,tokens[i],r.from,r.to)));if(2!=option&&!comments.every((c=>c)))return{changes:state.changes(ranges.map(((range,i)=>comments[i]?[]:[{from:range.from,insert:tokens[i].open+" "},{from:range.to,insert:" "+tokens[i].close}])))};if(1!=option&&comments.some((c=>c))){let changes=[];for(let comment,i=0;i<comments.length;i++)if(comment=comments[i]){let token=tokens[i],{open:open,close:close}=comment;changes.push({from:open.pos-token.open.length,to:open.pos+open.margin},{from:close.pos-close.margin,to:close.pos+token.close.length})}return{changes:changes}}return null}function changeLineComment(option,state,ranges=state.selection.ranges){let lines=[],prevLine=-1;for(let{from:from,to:to}of ranges){let startI=lines.length,minIndent=1e9,token=getConfig(state,from).line;if(token){for(let pos=from;pos<=to;){let line=state.doc.lineAt(pos);if(line.from>prevLine&&(from==to||to>line.from)){prevLine=line.from;let indent=/^\s*/.exec(line.text)[0].length,empty=indent==line.length,comment=line.text.slice(indent,indent+token.length)==token?indent:-1;indent<line.text.length&&indent<minIndent&&(minIndent=indent),lines.push({line:line,comment:comment,token:token,indent:indent,empty:empty,single:!1})}pos=line.to+1}if(minIndent<1e9)for(let i=startI;i<lines.length;i++)lines[i].indent<lines[i].line.text.length&&(lines[i].indent=minIndent);lines.length==startI+1&&(lines[startI].single=!0)}}if(2!=option&&lines.some((l=>l.comment<0&&(!l.empty||l.single)))){let changes=[];for(let{line:line,token:token,indent:indent,empty:empty,single:single}of lines)!single&&empty||changes.push({from:line.from+indent,insert:token+" "});let changeSet=state.changes(changes);return{changes:changeSet,selection:state.selection.map(changeSet,1)}}if(1!=option&&lines.some((l=>l.comment>=0))){let changes=[];for(let{line:line,comment:comment,token:token}of lines)if(comment>=0){let from=line.from+comment,to=from+token.length;" "==line.text[to-line.from]&&to++,changes.push({from:from,to:to})}return{changes:changes}}return null}const fromHistory=state.Annotation.define(),isolateHistory=state.Annotation.define(),invertedEffects=state.Facet.define(),historyConfig=state.Facet.define({combine:configs=>state.combineConfig(configs,{minDepth:100,newGroupDelay:500,joinToEvent:(_t,isAdjacent)=>isAdjacent},{minDepth:Math.max,newGroupDelay:Math.min,joinToEvent:(a,b)=>(tr,adj)=>a(tr,adj)||b(tr,adj)})}),historyField_=state.StateField.define({create:()=>HistoryState.empty,update(state$1,tr){let config=tr.state.facet(historyConfig),fromHist=tr.annotation(fromHistory);if(fromHist){let item=HistEvent.fromTransaction(tr,fromHist.selection),from=fromHist.side,other=0==from?state$1.undone:state$1.done;return other=item?updateBranch(other,other.length,config.minDepth,item):addSelection(other,tr.startState.selection),new HistoryState(0==from?fromHist.rest:other,0==from?other:fromHist.rest)}let isolate=tr.annotation(isolateHistory);if("full"!=isolate&&"before"!=isolate||(state$1=state$1.isolate()),!1===tr.annotation(state.Transaction.addToHistory))return tr.changes.empty?state$1:state$1.addMapping(tr.changes.desc);let event=HistEvent.fromTransaction(tr),time=tr.annotation(state.Transaction.time),userEvent=tr.annotation(state.Transaction.userEvent);return event?state$1=state$1.addChanges(event,time,userEvent,config,tr):tr.selection&&(state$1=state$1.addSelection(tr.startState.selection,time,userEvent,config.newGroupDelay)),"full"!=isolate&&"after"!=isolate||(state$1=state$1.isolate()),state$1},toJSON:value=>({done:value.done.map((e=>e.toJSON())),undone:value.undone.map((e=>e.toJSON()))}),fromJSON:json=>new HistoryState(json.done.map(HistEvent.fromJSON),json.undone.map(HistEvent.fromJSON))});const historyField=historyField_;function cmd(side,selection){return function({state:state,dispatch:dispatch}){if(!selection&&state.readOnly)return!1;let historyState=state.field(historyField_,!1);if(!historyState)return!1;let tr=historyState.pop(side,state,selection);return!!tr&&(dispatch(tr),!0)}}const undo=cmd(0,!1),redo=cmd(1,!1),undoSelection=cmd(0,!0),redoSelection=cmd(1,!0);function depth(side){return function(state){let histState=state.field(historyField_,!1);if(!histState)return 0;let branch=0==side?histState.done:histState.undone;return branch.length-(branch.length&&!branch[0].changes?1:0)}}const undoDepth=depth(0),redoDepth=depth(1);class HistEvent{constructor(changes,effects,mapped,startSelection,selectionsAfter){this.changes=changes,this.effects=effects,this.mapped=mapped,this.startSelection=startSelection,this.selectionsAfter=selectionsAfter}setSelAfter(after){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,after)}toJSON(){var _a,_b,_c;return{changes:null===(_a=this.changes)||void 0===_a?void 0:_a.toJSON(),mapped:null===(_b=this.mapped)||void 0===_b?void 0:_b.toJSON(),startSelection:null===(_c=this.startSelection)||void 0===_c?void 0:_c.toJSON(),selectionsAfter:this.selectionsAfter.map((s=>s.toJSON()))}}static fromJSON(json){return new HistEvent(json.changes&&state.ChangeSet.fromJSON(json.changes),[],json.mapped&&state.ChangeDesc.fromJSON(json.mapped),json.startSelection&&state.EditorSelection.fromJSON(json.startSelection),json.selectionsAfter.map(state.EditorSelection.fromJSON))}static fromTransaction(tr,selection){let effects=none;for(let invert of tr.startState.facet(invertedEffects)){let result=invert(tr);result.length&&(effects=effects.concat(result))}return!effects.length&&tr.changes.empty?null:new HistEvent(tr.changes.invert(tr.startState.doc),effects,void 0,selection||tr.startState.selection,none)}static selection(selections){return new HistEvent(void 0,none,void 0,void 0,selections)}}function updateBranch(branch,to,maxLen,newEvent){let start=to+1>maxLen+20?to-maxLen-1:0,newBranch=branch.slice(start,to);return newBranch.push(newEvent),newBranch}function conc(a,b){return a.length?b.length?a.concat(b):a:b}const none=[],MaxSelectionsPerEvent=200;function addSelection(branch,selection){if(branch.length){let lastEvent=branch[branch.length-1],sels=lastEvent.selectionsAfter.slice(Math.max(0,lastEvent.selectionsAfter.length-MaxSelectionsPerEvent));return sels.length&&sels[sels.length-1].eq(selection)?branch:(sels.push(selection),updateBranch(branch,branch.length-1,1e9,lastEvent.setSelAfter(sels)))}return[HistEvent.selection([selection])]}function popSelection(branch){let last=branch[branch.length-1],newBranch=branch.slice();return newBranch[branch.length-1]=last.setSelAfter(last.selectionsAfter.slice(0,last.selectionsAfter.length-1)),newBranch}function addMappingToBranch(branch,mapping){if(!branch.length)return branch;let length=branch.length,selections=none;for(;length;){let event=mapEvent(branch[length-1],mapping,selections);if(event.changes&&!event.changes.empty||event.effects.length){let result=branch.slice(0,length);return result[length-1]=event,result}mapping=event.mapped,length--,selections=event.selectionsAfter}return selections.length?[HistEvent.selection(selections)]:none}function mapEvent(event,mapping,extraSelections){let selections=conc(event.selectionsAfter.length?event.selectionsAfter.map((s=>s.map(mapping))):none,extraSelections);if(!event.changes)return HistEvent.selection(selections);let mappedChanges=event.changes.map(mapping),before=mapping.mapDesc(event.changes,!0),fullMapping=event.mapped?event.mapped.composeDesc(before):before;return new HistEvent(mappedChanges,state.StateEffect.mapEffects(event.effects,mapping),fullMapping,event.startSelection.map(before),selections)}const joinableUserEvent=/^(input\.type|delete)($|\.)/;class HistoryState{constructor(done,undone,prevTime=0,prevUserEvent=void 0){this.done=done,this.undone=undone,this.prevTime=prevTime,this.prevUserEvent=prevUserEvent}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(event,time,userEvent,config,tr){let done=this.done,lastEvent=done[done.length-1];return done=lastEvent&&lastEvent.changes&&!lastEvent.changes.empty&&event.changes&&(!userEvent||joinableUserEvent.test(userEvent))&&(!lastEvent.selectionsAfter.length&&time-this.prevTime<config.newGroupDelay&&config.joinToEvent(tr,function(a,b){let ranges=[],isAdjacent=!1;return a.iterChangedRanges(((f,t)=>ranges.push(f,t))),b.iterChangedRanges(((_f,_t,f,t)=>{for(let i=0;i<ranges.length;){let from=ranges[i++],to=ranges[i++];t>=from&&f<=to&&(isAdjacent=!0)}})),isAdjacent}(lastEvent.changes,event.changes))||"input.type.compose"==userEvent)?updateBranch(done,done.length-1,config.minDepth,new HistEvent(event.changes.compose(lastEvent.changes),conc(state.StateEffect.mapEffects(event.effects,lastEvent.changes),lastEvent.effects),lastEvent.mapped,lastEvent.startSelection,none)):updateBranch(done,done.length,config.minDepth,event),new HistoryState(done,none,time,userEvent)}addSelection(selection,time,userEvent,newGroupDelay){let last=this.done.length?this.done[this.done.length-1].selectionsAfter:none;return last.length>0&&time-this.prevTime<newGroupDelay&&userEvent==this.prevUserEvent&&userEvent&&/^select($|\.)/.test(userEvent)&&(a=last[last.length-1],b=selection,a.ranges.length==b.ranges.length&&0===a.ranges.filter(((r,i)=>r.empty!=b.ranges[i].empty)).length)?this:new HistoryState(addSelection(this.done,selection),this.undone,time,userEvent);var a,b}addMapping(mapping){return new HistoryState(addMappingToBranch(this.done,mapping),addMappingToBranch(this.undone,mapping),this.prevTime,this.prevUserEvent)}pop(side,state,onlySelection){let branch=0==side?this.done:this.undone;if(0==branch.length)return null;let event=branch[branch.length-1],selection=event.selectionsAfter[0]||state.selection;if(onlySelection&&event.selectionsAfter.length)return state.update({selection:event.selectionsAfter[event.selectionsAfter.length-1],annotations:fromHistory.of({side:side,rest:popSelection(branch),selection:selection}),userEvent:0==side?"select.undo":"select.redo",scrollIntoView:!0});if(event.changes){let rest=1==branch.length?none:branch.slice(0,branch.length-1);return event.mapped&&(rest=addMappingToBranch(rest,event.mapped)),state.update({changes:event.changes,selection:event.startSelection,effects:event.effects,annotations:fromHistory.of({side:side,rest:rest,selection:selection}),filter:!1,userEvent:0==side?"undo":"redo",scrollIntoView:!0})}return null}}HistoryState.empty=new HistoryState(none,none);const historyKeymap=[{key:"Mod-z",run:undo,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:!0},{linux:"Ctrl-Shift-z",run:redo,preventDefault:!0},{key:"Mod-u",run:undoSelection,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:redoSelection,preventDefault:!0}];function updateSel(sel,by){return state.EditorSelection.create(sel.ranges.map(by),sel.mainIndex)}function setSel(state,selection){return state.update({selection:selection,scrollIntoView:!0,userEvent:"select"})}function moveSel({state:state,dispatch:dispatch},how){let selection=updateSel(state.selection,how);return!selection.eq(state.selection,!0)&&(dispatch(setSel(state,selection)),!0)}function rangeEnd(range,forward){return state.EditorSelection.cursor(forward?range.to:range.from)}function cursorByChar(view,forward){return moveSel(view,(range=>range.empty?view.moveByChar(range,forward):rangeEnd(range,forward)))}function ltrAtCursor(view$1){return view$1.textDirectionAt(view$1.state.selection.main.head)==view.Direction.LTR}const cursorCharLeft=view=>cursorByChar(view,!ltrAtCursor(view)),cursorCharRight=view=>cursorByChar(view,ltrAtCursor(view));function byCharLogical(state$1,range,forward){let pos=range.head,line=state$1.doc.lineAt(pos);return pos=pos==(forward?line.to:line.from)?forward?Math.min(state$1.doc.length,line.to+1):Math.max(0,line.from-1):line.from+state.findClusterBreak(line.text,pos-line.from,forward),state.EditorSelection.cursor(pos,forward?-1:1)}function moveByCharLogical(target,forward){return moveSel(target,(range=>range.empty?byCharLogical(target.state,range,forward):rangeEnd(range,forward)))}function cursorByGroup(view,forward){return moveSel(view,(range=>range.empty?view.moveByGroup(range,forward):rangeEnd(range,forward)))}const cursorGroupLeft=view=>cursorByGroup(view,!ltrAtCursor(view)),cursorGroupRight=view=>cursorByGroup(view,ltrAtCursor(view)),segmenter="undefined"!=typeof Intl&&Intl.Segmenter?new Intl.Segmenter(void 0,{granularity:"word"}):null;function moveBySubword(view,range,forward){let categorize=view.state.charCategorizer(range.from),cat=state.CharCategory.Space,pos=range.from,steps=0,done=!1,sawUpper=!1,sawLower=!1,step=next=>{if(done)return!1;pos+=forward?next.length:-next.length;let ahead,nextCat=categorize(next);if(nextCat==state.CharCategory.Word&&next.charCodeAt(0)<128&&/[\W_]/.test(next)&&(nextCat=-1),cat==state.CharCategory.Space&&(cat=nextCat),cat!=nextCat)return!1;if(cat==state.CharCategory.Word)if(next.toLowerCase()==next){if(!forward&&sawUpper)return!1;sawLower=!0}else if(sawLower){if(forward)return!1;done=!0}else{if(sawUpper&&forward&&categorize(ahead=view.state.sliceDoc(pos,pos+1))==state.CharCategory.Word&&ahead.toLowerCase()==ahead)return!1;sawUpper=!0}return steps++,!0},end=view.moveByChar(range,forward,(start=>(step(start),step)));if(segmenter&&cat==state.CharCategory.Word&&end.from==range.from+steps*(forward?1:-1)){let from=Math.min(range.head,end.head),to=Math.max(range.head,end.head),skipped=view.state.sliceDoc(from,to);if(skipped.length>1&&/[\u4E00-\uffff]/.test(skipped)){let segments=Array.from(segmenter.segment(skipped));if(segments.length>1)return forward?state.EditorSelection.cursor(range.head+segments[1].index,-1):state.EditorSelection.cursor(end.head+segments[segments.length-1].index,1)}}return end}function cursorBySubword(view,forward){return moveSel(view,(range=>range.empty?moveBySubword(view,range,forward):rangeEnd(range,forward)))}function interestingNode(state,node,bracketProp){if(node.type.prop(bracketProp))return!0;let len=node.to-node.from;return len&&(len>2||/[^\s,.;:]/.test(state.sliceDoc(node.from,node.to)))||node.firstChild}function moveBySyntax(state$1,start,forward){let match,newPos,pos=language.syntaxTree(state$1).resolveInner(start.head),bracketProp=forward?common.NodeProp.closedBy:common.NodeProp.openedBy;for(let at=start.head;;){let next=forward?pos.childAfter(at):pos.childBefore(at);if(!next)break;interestingNode(state$1,next,bracketProp)?pos=next:at=forward?next.to:next.from}return newPos=pos.type.prop(bracketProp)&&(match=forward?language.matchBrackets(state$1,pos.from,1):language.matchBrackets(state$1,pos.to,-1))&&match.matched?forward?match.end.to:match.end.from:forward?pos.to:pos.from,state.EditorSelection.cursor(newPos,forward?-1:1)}const cursorSyntaxLeft=view=>moveSel(view,(range=>moveBySyntax(view.state,range,!ltrAtCursor(view)))),cursorSyntaxRight=view=>moveSel(view,(range=>moveBySyntax(view.state,range,ltrAtCursor(view))));function cursorByLine(view,forward){return moveSel(view,(range=>{if(!range.empty)return rangeEnd(range,forward);let moved=view.moveVertically(range,forward);return moved.head!=range.head?moved:view.moveToLineBoundary(range,forward)}))}const cursorLineUp=view=>cursorByLine(view,!1),cursorLineDown=view=>cursorByLine(view,!0);function pageInfo(view$1){let height,selfScroll=view$1.scrollDOM.clientHeight<view$1.scrollDOM.scrollHeight-2,marginTop=0,marginBottom=0;if(selfScroll){for(let source of view$1.state.facet(view.EditorView.scrollMargins)){let margins=source(view$1);(null==margins?void 0:margins.top)&&(marginTop=Math.max(null==margins?void 0:margins.top,marginTop)),(null==margins?void 0:margins.bottom)&&(marginBottom=Math.max(null==margins?void 0:margins.bottom,marginBottom))}height=view$1.scrollDOM.clientHeight-marginTop-marginBottom}else height=(view$1.dom.ownerDocument.defaultView||window).innerHeight;return{marginTop:marginTop,marginBottom:marginBottom,selfScroll:selfScroll,height:Math.max(view$1.defaultLineHeight,height-5)}}function cursorByPage(view$1,forward){let effect,page=pageInfo(view$1),{state:state}=view$1,selection=updateSel(state.selection,(range=>range.empty?view$1.moveVertically(range,forward,page.height):rangeEnd(range,forward)));if(selection.eq(state.selection))return!1;if(page.selfScroll){let startPos=view$1.coordsAtPos(state.selection.main.head),scrollRect=view$1.scrollDOM.getBoundingClientRect(),scrollTop=scrollRect.top+page.marginTop,scrollBottom=scrollRect.bottom-page.marginBottom;startPos&&startPos.top>scrollTop&&startPos.bottom<scrollBottom&&(effect=view.EditorView.scrollIntoView(selection.main.head,{y:"start",yMargin:startPos.top-scrollTop}))}return view$1.dispatch(setSel(state,selection),{effects:effect}),!0}const cursorPageUp=view=>cursorByPage(view,!1),cursorPageDown=view=>cursorByPage(view,!0);function moveByLineBoundary(view,start,forward){let line=view.lineBlockAt(start.head),moved=view.moveToLineBoundary(start,forward);if(moved.head==start.head&&moved.head!=(forward?line.to:line.from)&&(moved=view.moveToLineBoundary(start,forward,!1)),!forward&&moved.head==line.from&&line.length){let space=/^\s*/.exec(view.state.sliceDoc(line.from,Math.min(line.from+100,line.to)))[0].length;space&&start.head!=line.from+space&&(moved=state.EditorSelection.cursor(line.from+space))}return moved}const cursorLineBoundaryForward=view=>moveSel(view,(range=>moveByLineBoundary(view,range,!0))),cursorLineBoundaryBackward=view=>moveSel(view,(range=>moveByLineBoundary(view,range,!1))),cursorLineBoundaryLeft=view=>moveSel(view,(range=>moveByLineBoundary(view,range,!ltrAtCursor(view)))),cursorLineBoundaryRight=view=>moveSel(view,(range=>moveByLineBoundary(view,range,ltrAtCursor(view)))),cursorLineStart=view=>moveSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).from,1))),cursorLineEnd=view=>moveSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).to,-1)));function toMatchingBracket(state$1,dispatch,extend){let found=!1,selection=updateSel(state$1.selection,(range=>{let matching=language.matchBrackets(state$1,range.head,-1)||language.matchBrackets(state$1,range.head,1)||range.head>0&&language.matchBrackets(state$1,range.head-1,1)||range.head<state$1.doc.length&&language.matchBrackets(state$1,range.head+1,-1);if(!matching||!matching.end)return range;found=!0;let head=matching.start.from==range.head?matching.end.to:matching.end.from;return extend?state.EditorSelection.range(range.anchor,head):state.EditorSelection.cursor(head)}));return!!found&&(dispatch(setSel(state$1,selection)),!0)}const cursorMatchingBracket=({state:state,dispatch:dispatch})=>toMatchingBracket(state,dispatch,!1);function extendSel(target,how){let selection=updateSel(target.state.selection,(range=>{let head=how(range);return state.EditorSelection.range(range.anchor,head.head,head.goalColumn,head.bidiLevel||void 0)}));return!selection.eq(target.state.selection)&&(target.dispatch(setSel(target.state,selection)),!0)}function selectByChar(view,forward){return extendSel(view,(range=>view.moveByChar(range,forward)))}const selectCharLeft=view=>selectByChar(view,!ltrAtCursor(view)),selectCharRight=view=>selectByChar(view,ltrAtCursor(view));function selectByGroup(view,forward){return extendSel(view,(range=>view.moveByGroup(range,forward)))}const selectGroupLeft=view=>selectByGroup(view,!ltrAtCursor(view)),selectGroupRight=view=>selectByGroup(view,ltrAtCursor(view));function selectBySubword(view,forward){return extendSel(view,(range=>moveBySubword(view,range,forward)))}const selectSyntaxLeft=view=>extendSel(view,(range=>moveBySyntax(view.state,range,!ltrAtCursor(view)))),selectSyntaxRight=view=>extendSel(view,(range=>moveBySyntax(view.state,range,ltrAtCursor(view))));function selectByLine(view,forward){return extendSel(view,(range=>view.moveVertically(range,forward)))}const selectLineUp=view=>selectByLine(view,!1),selectLineDown=view=>selectByLine(view,!0);function selectByPage(view,forward){return extendSel(view,(range=>view.moveVertically(range,forward,pageInfo(view).height)))}const selectPageUp=view=>selectByPage(view,!1),selectPageDown=view=>selectByPage(view,!0),selectLineBoundaryForward=view=>extendSel(view,(range=>moveByLineBoundary(view,range,!0))),selectLineBoundaryBackward=view=>extendSel(view,(range=>moveByLineBoundary(view,range,!1))),selectLineBoundaryLeft=view=>extendSel(view,(range=>moveByLineBoundary(view,range,!ltrAtCursor(view)))),selectLineBoundaryRight=view=>extendSel(view,(range=>moveByLineBoundary(view,range,ltrAtCursor(view)))),selectLineStart=view=>extendSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).from))),selectLineEnd=view=>extendSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).to))),cursorDocStart=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:0})),!0),cursorDocEnd=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:state.doc.length})),!0),selectDocStart=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:state.selection.main.anchor,head:0})),!0),selectDocEnd=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:state.selection.main.anchor,head:state.doc.length})),!0),selectAll=({state:state,dispatch:dispatch})=>(dispatch(state.update({selection:{anchor:0,head:state.doc.length},userEvent:"select"})),!0),selectLine=({state:state$1,dispatch:dispatch})=>{let ranges=selectedLineBlocks(state$1).map((({from:from,to:to})=>state.EditorSelection.range(from,Math.min(to+1,state$1.doc.length))));return dispatch(state$1.update({selection:state.EditorSelection.create(ranges),userEvent:"select"})),!0},selectParentSyntax=({state:state$1,dispatch:dispatch})=>{let selection=updateSel(state$1.selection,(range=>{let tree=language.syntaxTree(state$1),stack=tree.resolveStack(range.from,1);if(range.empty){let stackBefore=tree.resolveStack(range.from,-1);stackBefore.node.from>=stack.node.from&&stackBefore.node.to<=stack.node.to&&(stack=stackBefore)}for(let cur=stack;cur;cur=cur.next){let{node:node}=cur;if((node.from<range.from&&node.to>=range.to||node.to>range.to&&node.from<=range.from)&&cur.next)return state.EditorSelection.range(node.to,node.from)}return range}));return!selection.eq(state$1.selection)&&(dispatch(setSel(state$1,selection)),!0)},simplifySelection=({state:state$1,dispatch:dispatch})=>{let cur=state$1.selection,selection=null;return cur.ranges.length>1?selection=state.EditorSelection.create([cur.main]):cur.main.empty||(selection=state.EditorSelection.create([state.EditorSelection.cursor(cur.main.head)])),!!selection&&(dispatch(setSel(state$1,selection)),!0)};function deleteBy(target,by){if(target.state.readOnly)return!1;let event="delete.selection",{state:state$1}=target,changes=state$1.changeByRange((range=>{let{from:from,to:to}=range;if(from==to){let towards=by(range);towards<from?(event="delete.backward",towards=skipAtomic(target,towards,!1)):towards>from&&(event="delete.forward",towards=skipAtomic(target,towards,!0)),from=Math.min(from,towards),to=Math.max(to,towards)}else from=skipAtomic(target,from,!1),to=skipAtomic(target,to,!0);return from==to?{range:range}:{changes:{from:from,to:to},range:state.EditorSelection.cursor(from,from<range.head?-1:1)}}));return!changes.changes.empty&&(target.dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:event,effects:"delete.selection"==event?view.EditorView.announce.of(state$1.phrase("Selection deleted")):void 0})),!0)}function skipAtomic(target,pos,forward){if(target instanceof view.EditorView)for(let ranges of target.state.facet(view.EditorView.atomicRanges).map((f=>f(target))))ranges.between(pos,pos,((from,to)=>{from<pos&&to>pos&&(pos=forward?to:from)}));return pos}const deleteByChar=(target,forward,byIndentUnit)=>deleteBy(target,(range=>{let before,targetPos,pos=range.from,{state:state$1}=target,line=state$1.doc.lineAt(pos);if(byIndentUnit&&!forward&&pos>line.from&&pos<line.from+200&&!/[^ \t]/.test(before=line.text.slice(0,pos-line.from))){if("\t"==before[before.length-1])return pos-1;let drop=state.countColumn(before,state$1.tabSize)%language.getIndentUnit(state$1)||language.getIndentUnit(state$1);for(let i=0;i<drop&&" "==before[before.length-1-i];i++)pos--;targetPos=pos}else targetPos=state.findClusterBreak(line.text,pos-line.from,forward,forward)+line.from,targetPos==pos&&line.number!=(forward?state$1.doc.lines:1)?targetPos+=forward?1:-1:!forward&&/[\ufe00-\ufe0f]/.test(line.text.slice(targetPos-line.from,pos-line.from))&&(targetPos=state.findClusterBreak(line.text,targetPos-line.from,!1,!1)+line.from);return targetPos})),deleteCharBackward=view=>deleteByChar(view,!1,!0),deleteCharForward=view=>deleteByChar(view,!0,!1),deleteByGroup=(target,forward)=>deleteBy(target,(range=>{let pos=range.head,{state:state$1}=target,line=state$1.doc.lineAt(pos),categorize=state$1.charCategorizer(pos);for(let cat=null;;){if(pos==(forward?line.to:line.from)){pos==range.head&&line.number!=(forward?state$1.doc.lines:1)&&(pos+=forward?1:-1);break}let next=state.findClusterBreak(line.text,pos-line.from,forward)+line.from,nextChar=line.text.slice(Math.min(pos,next)-line.from,Math.max(pos,next)-line.from),nextCat=categorize(nextChar);if(null!=cat&&nextCat!=cat)break;" "==nextChar&&pos==range.head||(cat=nextCat),pos=next}return pos})),deleteGroupBackward=target=>deleteByGroup(target,!1),deleteGroupForward=target=>deleteByGroup(target,!0),deleteToLineEnd=view=>deleteBy(view,(range=>{let lineEnd=view.lineBlockAt(range.head).to;return range.head<lineEnd?lineEnd:Math.min(view.state.doc.length,range.head+1)})),deleteLineBoundaryBackward=view=>deleteBy(view,(range=>{let lineStart=view.moveToLineBoundary(range,!1).head;return range.head>lineStart?lineStart:Math.max(0,range.head-1)})),deleteLineBoundaryForward=view=>deleteBy(view,(range=>{let lineStart=view.moveToLineBoundary(range,!0).head;return range.head<lineStart?lineStart:Math.min(view.state.doc.length,range.head+1)})),splitLine=({state:state$1,dispatch:dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange((range=>({changes:{from:range.from,to:range.to,insert:state.Text.of(["",""])},range:state.EditorSelection.cursor(range.from)})));return dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"})),!0},transposeChars=({state:state$1,dispatch:dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange((range=>{if(!range.empty||0==range.from||range.from==state$1.doc.length)return{range:range};let pos=range.from,line=state$1.doc.lineAt(pos),from=pos==line.from?pos-1:state.findClusterBreak(line.text,pos-line.from,!1)+line.from,to=pos==line.to?pos+1:state.findClusterBreak(line.text,pos-line.from,!0)+line.from;return{changes:{from:from,to:to,insert:state$1.doc.slice(pos,to).append(state$1.doc.slice(from,pos))},range:state.EditorSelection.cursor(to)}}));return!changes.changes.empty&&(dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"move.character"})),!0)};function selectedLineBlocks(state){let blocks=[],upto=-1;for(let range of state.selection.ranges){let startLine=state.doc.lineAt(range.from),endLine=state.doc.lineAt(range.to);if(range.empty||range.to!=endLine.from||(endLine=state.doc.lineAt(range.to-1)),upto>=startLine.number){let prev=blocks[blocks.length-1];prev.to=endLine.to,prev.ranges.push(range)}else blocks.push({from:startLine.from,to:endLine.to,ranges:[range]});upto=endLine.number+1}return blocks}function moveLine(state$1,dispatch,forward){if(state$1.readOnly)return!1;let changes=[],ranges=[];for(let block of selectedLineBlocks(state$1)){if(forward?block.to==state$1.doc.length:0==block.from)continue;let nextLine=state$1.doc.lineAt(forward?block.to+1:block.from-1),size=nextLine.length+1;if(forward){changes.push({from:block.to,to:nextLine.to},{from:block.from,insert:nextLine.text+state$1.lineBreak});for(let r of block.ranges)ranges.push(state.EditorSelection.range(Math.min(state$1.doc.length,r.anchor+size),Math.min(state$1.doc.length,r.head+size)))}else{changes.push({from:nextLine.from,to:block.from},{from:block.to,insert:state$1.lineBreak+nextLine.text});for(let r of block.ranges)ranges.push(state.EditorSelection.range(r.anchor-size,r.head-size))}}return!!changes.length&&(dispatch(state$1.update({changes:changes,scrollIntoView:!0,selection:state.EditorSelection.create(ranges,state$1.selection.mainIndex),userEvent:"move.line"})),!0)}const moveLineUp=({state:state,dispatch:dispatch})=>moveLine(state,dispatch,!1),moveLineDown=({state:state,dispatch:dispatch})=>moveLine(state,dispatch,!0);function copyLine(state,dispatch,forward){if(state.readOnly)return!1;let changes=[];for(let block of selectedLineBlocks(state))forward?changes.push({from:block.from,insert:state.doc.slice(block.from,block.to)+state.lineBreak}):changes.push({from:block.to,insert:state.lineBreak+state.doc.slice(block.from,block.to)});return dispatch(state.update({changes:changes,scrollIntoView:!0,userEvent:"input.copyline"})),!0}const copyLineUp=({state:state,dispatch:dispatch})=>copyLine(state,dispatch,!1),copyLineDown=({state:state,dispatch:dispatch})=>copyLine(state,dispatch,!0),deleteLine=view=>{if(view.state.readOnly)return!1;let{state:state}=view,changes=state.changes(selectedLineBlocks(state).map((({from:from,to:to})=>(from>0?from--:to<state.doc.length&&to++,{from:from,to:to})))),selection=updateSel(state.selection,(range=>{let dist;if(view.lineWrapping){let block=view.lineBlockAt(range.head),pos=view.coordsAtPos(range.head,range.assoc||1);pos&&(dist=block.bottom+view.documentTop-pos.bottom+view.defaultLineHeight/2)}return view.moveVertically(range,!0,dist)})).map(changes);return view.dispatch({changes:changes,selection:selection,scrollIntoView:!0,userEvent:"delete.line"}),!0};const insertNewlineAndIndent=newlineAndIndent(!1),insertBlankLine=newlineAndIndent(!0);function newlineAndIndent(atEof){return({state:state$1,dispatch:dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange((range=>{let{from:from,to:to}=range,line=state$1.doc.lineAt(from),explode=!atEof&&from==to&&function(state,pos){if(/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos-1,pos+1)))return{from:pos,to:pos};let closedBy,context=language.syntaxTree(state).resolveInner(pos),before=context.childBefore(pos),after=context.childAfter(pos);return before&&after&&before.to<=pos&&after.from>=pos&&(closedBy=before.type.prop(common.NodeProp.closedBy))&&closedBy.indexOf(after.name)>-1&&state.doc.lineAt(before.to).from==state.doc.lineAt(after.from).from&&!/\S/.test(state.sliceDoc(before.to,after.from))?{from:before.to,to:after.from}:null}(state$1,from);atEof&&(from=to=(to<=line.to?line:state$1.doc.lineAt(to)).to);let cx=new language.IndentContext(state$1,{simulateBreak:from,simulateDoubleBreak:!!explode}),indent=language.getIndentation(cx,from);for(null==indent&&(indent=state.countColumn(/^\s*/.exec(state$1.doc.lineAt(from).text)[0],state$1.tabSize));to<line.to&&/\s/.test(line.text[to-line.from]);)to++;explode?({from:from,to:to}=explode):from>line.from&&from<line.from+100&&!/\S/.test(line.text.slice(0,from))&&(from=line.from);let insert=["",language.indentString(state$1,indent)];return explode&&insert.push(language.indentString(state$1,cx.lineIndent(line.from,-1))),{changes:{from:from,to:to,insert:state.Text.of(insert)},range:state.EditorSelection.cursor(from+1+insert[1].length)}}));return dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"})),!0}}function changeBySelectedLine(state$1,f){let atLine=-1;return state$1.changeByRange((range=>{let changes=[];for(let pos=range.from;pos<=range.to;){let line=state$1.doc.lineAt(pos);line.number>atLine&&(range.empty||range.to>line.from)&&(f(line,changes,range),atLine=line.number),pos=line.to+1}let changeSet=state$1.changes(changes);return{changes:changes,range:state.EditorSelection.range(changeSet.mapPos(range.anchor,1),changeSet.mapPos(range.head,1))}}))}const indentSelection=({state:state,dispatch:dispatch})=>{if(state.readOnly)return!1;let updated=Object.create(null),context=new language.IndentContext(state,{overrideIndentation:start=>{let found=updated[start];return null==found?-1:found}}),changes=changeBySelectedLine(state,((line,changes,range)=>{let indent=language.getIndentation(context,line.from);if(null==indent)return;/\S/.test(line.text)||(indent=0);let cur=/^\s*/.exec(line.text)[0],norm=language.indentString(state,indent);(cur!=norm||range.from<line.from+cur.length)&&(updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm}))}));return changes.changes.empty||dispatch(state.update(changes,{userEvent:"indent"})),!0},indentMore=({state:state,dispatch:dispatch})=>!state.readOnly&&(dispatch(state.update(changeBySelectedLine(state,((line,changes)=>{changes.push({from:line.from,insert:state.facet(language.indentUnit)})})),{userEvent:"input.indent"})),!0),indentLess=({state:state$1,dispatch:dispatch})=>!state$1.readOnly&&(dispatch(state$1.update(changeBySelectedLine(state$1,((line,changes)=>{let space=/^\s*/.exec(line.text)[0];if(!space)return;let col=state.countColumn(space,state$1.tabSize),keep=0,insert=language.indentString(state$1,Math.max(0,col-language.getIndentUnit(state$1)));for(;keep<space.length&&keep<insert.length&&space.charCodeAt(keep)==insert.charCodeAt(keep);)keep++;changes.push({from:line.from+keep,to:line.from+space.length,insert:insert.slice(keep)})})),{userEvent:"delete.dedent"})),!0),toggleTabFocusMode=view=>(view.setTabFocusMode(),!0),emacsStyleKeymap=[{key:"Ctrl-b",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:cursorCharRight,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown}],standardKeymap=[{key:"ArrowLeft",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:cursorGroupLeft,shift:selectGroupLeft,preventDefault:!0},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryLeft,shift:selectLineBoundaryLeft,preventDefault:!0},{key:"ArrowRight",run:cursorCharRight,shift:selectCharRight,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight,preventDefault:!0},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryRight,shift:selectLineBoundaryRight,preventDefault:!0},{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp,preventDefault:!0},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:!0},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward,preventDefault:!0},{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward,preventDefault:!0},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent,shift:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},{mac:"Mod-Backspace",run:deleteLineBoundaryBackward},{mac:"Mod-Delete",run:deleteLineBoundaryForward}].concat(emacsStyleKeymap.map((b=>({mac:b.key,run:b.run,shift:b.shift})))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},{key:"Escape",run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket},{key:"Mod-/",run:toggleComment},{key:"Alt-A",run:toggleBlockComment},{key:"Ctrl-m",mac:"Shift-Alt-m",run:toggleTabFocusMode}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};return dist$3.blockComment=blockComment,dist$3.blockUncomment=blockUncomment,dist$3.copyLineDown=copyLineDown,dist$3.copyLineUp=copyLineUp,dist$3.cursorCharBackward=view=>cursorByChar(view,!1),dist$3.cursorCharBackwardLogical=target=>moveByCharLogical(target,!1),dist$3.cursorCharForward=view=>cursorByChar(view,!0),dist$3.cursorCharForwardLogical=target=>moveByCharLogical(target,!0),dist$3.cursorCharLeft=cursorCharLeft,dist$3.cursorCharRight=cursorCharRight,dist$3.cursorDocEnd=cursorDocEnd,dist$3.cursorDocStart=cursorDocStart,dist$3.cursorGroupBackward=view=>cursorByGroup(view,!1),dist$3.cursorGroupForward=view=>cursorByGroup(view,!0),dist$3.cursorGroupLeft=cursorGroupLeft,dist$3.cursorGroupRight=cursorGroupRight,dist$3.cursorLineBoundaryBackward=cursorLineBoundaryBackward,dist$3.cursorLineBoundaryForward=cursorLineBoundaryForward,dist$3.cursorLineBoundaryLeft=cursorLineBoundaryLeft,dist$3.cursorLineBoundaryRight=cursorLineBoundaryRight,dist$3.cursorLineDown=cursorLineDown,dist$3.cursorLineEnd=cursorLineEnd,dist$3.cursorLineStart=cursorLineStart,dist$3.cursorLineUp=cursorLineUp,dist$3.cursorMatchingBracket=cursorMatchingBracket,dist$3.cursorPageDown=cursorPageDown,dist$3.cursorPageUp=cursorPageUp,dist$3.cursorSubwordBackward=view=>cursorBySubword(view,!1),dist$3.cursorSubwordForward=view=>cursorBySubword(view,!0),dist$3.cursorSyntaxLeft=cursorSyntaxLeft,dist$3.cursorSyntaxRight=cursorSyntaxRight,dist$3.defaultKeymap=defaultKeymap,dist$3.deleteCharBackward=deleteCharBackward,dist$3.deleteCharBackwardStrict=view=>deleteByChar(view,!1,!1),dist$3.deleteCharForward=deleteCharForward,dist$3.deleteGroupBackward=deleteGroupBackward,dist$3.deleteGroupForward=deleteGroupForward,dist$3.deleteLine=deleteLine,dist$3.deleteLineBoundaryBackward=deleteLineBoundaryBackward,dist$3.deleteLineBoundaryForward=deleteLineBoundaryForward,dist$3.deleteToLineEnd=deleteToLineEnd,dist$3.deleteToLineStart=view=>deleteBy(view,(range=>{let lineStart=view.lineBlockAt(range.head).from;return range.head>lineStart?lineStart:Math.max(0,range.head-1)})),dist$3.deleteTrailingWhitespace=({state:state,dispatch:dispatch})=>{if(state.readOnly)return!1;let changes=[];for(let pos=0,prev="",iter=state.doc.iter();;){if(iter.next(),iter.lineBreak||iter.done){let trailing=prev.search(/\s+$/);if(trailing>-1&&changes.push({from:pos-(prev.length-trailing),to:pos}),iter.done)break;prev=""}else prev=iter.value;pos+=iter.value.length}return!!changes.length&&(dispatch(state.update({changes:changes,userEvent:"delete"})),!0)},dist$3.emacsStyleKeymap=emacsStyleKeymap,dist$3.history=function(config={}){return[historyField_,historyConfig.of(config),view.EditorView.domEventHandlers({beforeinput(e,view){let command="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;return!!command&&(e.preventDefault(),command(view))}})]},dist$3.historyField=historyField,dist$3.historyKeymap=historyKeymap,dist$3.indentLess=indentLess,dist$3.indentMore=indentMore,dist$3.indentSelection=indentSelection,dist$3.indentWithTab=indentWithTab,dist$3.insertBlankLine=insertBlankLine,dist$3.insertNewline=({state:state,dispatch:dispatch})=>(dispatch(state.update(state.replaceSelection(state.lineBreak),{scrollIntoView:!0,userEvent:"input"})),!0),dist$3.insertNewlineAndIndent=insertNewlineAndIndent,dist$3.insertNewlineKeepIndent=({state:state$1,dispatch:dispatch})=>(dispatch(state$1.update(state$1.changeByRange((range=>{let indent=/^\s*/.exec(state$1.doc.lineAt(range.from).text)[0];return{changes:{from:range.from,to:range.to,insert:state$1.lineBreak+indent},range:state.EditorSelection.cursor(range.from+indent.length+1)}})),{scrollIntoView:!0,userEvent:"input"})),!0),dist$3.insertTab=({state:state,dispatch:dispatch})=>state.selection.ranges.some((r=>!r.empty))?indentMore({state:state,dispatch:dispatch}):(dispatch(state.update(state.replaceSelection("\t"),{scrollIntoView:!0,userEvent:"input"})),!0),dist$3.invertedEffects=invertedEffects,dist$3.isolateHistory=isolateHistory,dist$3.lineComment=lineComment,dist$3.lineUncomment=lineUncomment,dist$3.moveLineDown=moveLineDown,dist$3.moveLineUp=moveLineUp,dist$3.redo=redo,dist$3.redoDepth=redoDepth,dist$3.redoSelection=redoSelection,dist$3.selectAll=selectAll,dist$3.selectCharBackward=view=>selectByChar(view,!1),dist$3.selectCharBackwardLogical=target=>extendSel(target,(range=>byCharLogical(target.state,range,!1))),dist$3.selectCharForward=view=>selectByChar(view,!0),dist$3.selectCharForwardLogical=target=>extendSel(target,(range=>byCharLogical(target.state,range,!0))),dist$3.selectCharLeft=selectCharLeft,dist$3.selectCharRight=selectCharRight,dist$3.selectDocEnd=selectDocEnd,dist$3.selectDocStart=selectDocStart,dist$3.selectGroupBackward=view=>selectByGroup(view,!1),dist$3.selectGroupForward=view=>selectByGroup(view,!0),dist$3.selectGroupLeft=selectGroupLeft,dist$3.selectGroupRight=selectGroupRight,dist$3.selectLine=selectLine,dist$3.selectLineBoundaryBackward=selectLineBoundaryBackward,dist$3.selectLineBoundaryForward=selectLineBoundaryForward,dist$3.selectLineBoundaryLeft=selectLineBoundaryLeft,dist$3.selectLineBoundaryRight=selectLineBoundaryRight,dist$3.selectLineDown=selectLineDown,dist$3.selectLineEnd=selectLineEnd,dist$3.selectLineStart=selectLineStart,dist$3.selectLineUp=selectLineUp,dist$3.selectMatchingBracket=({state:state,dispatch:dispatch})=>toMatchingBracket(state,dispatch,!0),dist$3.selectPageDown=selectPageDown,dist$3.selectPageUp=selectPageUp,dist$3.selectParentSyntax=selectParentSyntax,dist$3.selectSubwordBackward=view=>selectBySubword(view,!1),dist$3.selectSubwordForward=view=>selectBySubword(view,!0),dist$3.selectSyntaxLeft=selectSyntaxLeft,dist$3.selectSyntaxRight=selectSyntaxRight,dist$3.simplifySelection=simplifySelection,dist$3.splitLine=splitLine,dist$3.standardKeymap=standardKeymap,dist$3.temporarilySetTabFocusMode=view=>(view.setTabFocusMode(2e3),!0),dist$3.toggleBlockComment=toggleBlockComment,dist$3.toggleBlockCommentByLine=toggleBlockCommentByLine,dist$3.toggleComment=toggleComment,dist$3.toggleLineComment=toggleLineComment,dist$3.toggleTabFocusMode=toggleTabFocusMode,dist$3.transposeChars=transposeChars,dist$3.undo=undo,dist$3.undoDepth=undoDepth,dist$3.undoSelection=undoSelection,dist$3}var hasRequiredUtilities,hasRequiredItalic,Italic={},Utilities={};function requireUtilities(){if(hasRequiredUtilities)return Utilities;hasRequiredUtilities=1,Object.defineProperty(Utilities,"__esModule",{value:!0}),Utilities.addPrefixToSelection=Utilities.trimSelection=Utilities.wrapString=void 0;Utilities.wrapString=(text,prefix,postfix)=>`${prefix}${text.trim()}${postfix}`;Utilities.trimSelection=(text,range)=>{const originalText=text;if(text.trim().length<1)return{text:"",rangeFrom:range.from,rangeTo:range.to,spaceLeft:0,spaceRight:0};let spaceLeft=0,spaceRight=0;for(let i=0;i<originalText.length&&" "===originalText[i];i++)spaceLeft+=1;for(let i=originalText.length-1;i>-1&&" "===originalText[i];i--)spaceRight+=1;return{text:originalText.substring(spaceLeft,originalText.length-spaceRight),rangeFrom:range.from+spaceLeft,rangeTo:range.to-spaceRight,spaceLeft:spaceLeft,spaceRight:spaceRight}};return Utilities.addPrefixToSelection=(prefix,state,range)=>{const docText=state.doc.toString();let text=state.sliceDoc(range.from,range.to),rangeFrom=range.from;for(;rangeFrom>0&&"\n"!==docText[rangeFrom-1];)rangeFrom-=1;text=state.sliceDoc(rangeFrom,range.to);const textBefore=`\n${text}`,newText=textBefore.replace(/\n/g,`\n${prefix}`);return{from:rangeFrom,to:range.to,insert:newText,anchor:rangeFrom+prefix.length+1,textBefore:textBefore}},Utilities}function requireItalic(){if(hasRequiredItalic)return Italic;hasRequiredItalic=1,Object.defineProperty(Italic,"__esModule",{value:!0}),Italic.italicKeyBinding=void 0,Italic.italic=italic;const state_1=require$$0,Utilities_1=requireUtilities();function italic(view){const transaction=view.state.changeByRange((range=>function(range,state){const originalText=state.sliceDoc(range.from,range.to),{text:text,rangeFrom:rangeFrom,rangeTo:rangeTo}=(0,Utilities_1.trimSelection)(originalText,range);return{changes:{from:rangeFrom,insert:`_${text}_`,to:rangeTo},range:state_1.EditorSelection.range(rangeFrom+1,rangeTo+1)}}(range,view.state)));return view.dispatch(transaction),!0}return Italic.italicKeyBinding={key:"Ctrl-i",run:italic},Italic}var hasRequiredBold,Bold={};function requireBold(){if(hasRequiredBold)return Bold;hasRequiredBold=1,Object.defineProperty(Bold,"__esModule",{value:!0}),Bold.boldKeyBinding=void 0,Bold.bold=bold;const state_1=require$$0,Utilities_1=requireUtilities();function bold(view){const transaction=view.state.changeByRange((range=>function(range,state){const originalText=state.sliceDoc(range.from,range.to),{text:text,rangeFrom:rangeFrom,rangeTo:rangeTo}=(0,Utilities_1.trimSelection)(originalText,range);return{changes:{from:rangeFrom,insert:`**${text}**`,to:rangeTo},range:state_1.EditorSelection.range(rangeFrom+2,rangeTo+2)}}(range,view.state)));return view.dispatch(transaction),!0}return Bold.boldKeyBinding={key:"Ctrl-b",run:bold},Bold}var hasRequiredCode,Code={};function requireCode(){if(hasRequiredCode)return Code;hasRequiredCode=1,Object.defineProperty(Code,"__esModule",{value:!0}),Code.codeKeyBinding=void 0,Code.code=code;const state_1=require$$0,Utilities_1=requireUtilities();function code(view){const transaction=view.state.changeByRange((range=>function(range,state){const originalText=state.sliceDoc(range.from,range.to),{text:text,rangeFrom:rangeFrom,rangeTo:rangeTo}=(0,Utilities_1.trimSelection)(originalText,range);let newText,selection;return originalText.includes("\n")?(newText=`\`\`\`\n${text}\n\`\`\``,selection=state_1.EditorSelection.range(rangeFrom+4,rangeTo+4)):(newText=`\`${text}\``,selection=state_1.EditorSelection.range(rangeFrom+1,rangeTo+1)),{changes:{from:rangeFrom,insert:newText,to:rangeTo},range:selection}}(range,view.state)));return view.dispatch(transaction),!0}return Code.codeKeyBinding={key:"Ctrl-e",run:code},Code}var hasRequiredLink,Link={};function requireLink(){if(hasRequiredLink)return Link;hasRequiredLink=1,Object.defineProperty(Link,"__esModule",{value:!0}),Link.linkKeyBinding=void 0,Link.link=link;const state_1=require$$0,Utilities_1=requireUtilities();function link(view){const transaction=view.state.changeByRange((range=>function(range,state){const originalText=state.sliceDoc(range.from,range.to),{text:text,rangeFrom:rangeFrom,rangeTo:rangeTo}=(0,Utilities_1.trimSelection)(originalText,range);return{changes:{from:rangeFrom,insert:originalText.startsWith("http")?`[](${text})`:`[${text}](url)`,to:rangeTo},range:state_1.EditorSelection.range(rangeFrom+1,rangeFrom+1)}}(range,view.state)));return view.dispatch(transaction),!0}return Link.linkKeyBinding={key:"Ctrl-k",run:link},Link}var hasRequiredQuote,Quote={};function requireQuote(){if(hasRequiredQuote)return Quote;hasRequiredQuote=1,Object.defineProperty(Quote,"__esModule",{value:!0}),Quote.quoteKeyBinding=void 0,Quote.quote=quote;const state_1=require$$0,Utilities_1=requireUtilities();function quote(view){const transaction=view.state.changeByRange((range=>function(range,state){const changes=(0,Utilities_1.addPrefixToSelection)("> ",state,range);return{changes:changes,range:state_1.EditorSelection.range(changes.anchor,changes.anchor)}}(range,view.state)));return view.dispatch(transaction),!0}return Quote.quoteKeyBinding={key:"Ctrl-Shift-.",run:quote},Quote}var hasRequiredBulletedList,BulletedList={};function requireBulletedList(){if(hasRequiredBulletedList)return BulletedList;hasRequiredBulletedList=1,Object.defineProperty(BulletedList,"__esModule",{value:!0}),BulletedList.ulKeyBinding=void 0,BulletedList.ul=ul;const state_1=require$$0,Utilities_1=requireUtilities();function ul(view){const transaction=view.state.changeByRange((range=>function(range,state){const changes=(0,Utilities_1.addPrefixToSelection)("- ",state,range);return{changes:changes,range:state_1.EditorSelection.range(changes.anchor,changes.anchor)}}(range,view.state)));return view.dispatch(transaction),!0}return BulletedList.ulKeyBinding={key:"Ctrl-Shift-8",run:ul},BulletedList}var hasRequiredHeading,hasRequiredToolbar,Toolbar={},Heading={};function requireHeading(){if(hasRequiredHeading)return Heading;hasRequiredHeading=1,Object.defineProperty(Heading,"__esModule",{value:!0}),Heading.heading=function(view){const transaction=view.state.changeByRange((range=>function(range,state){const changes=(0,Utilities_1.addPrefixToSelection)("### ",state,range);return{changes:changes,range:state_1.EditorSelection.range(changes.anchor,changes.anchor)}}(range,view.state)));return view.dispatch(transaction),!0};const state_1=require$$0,Utilities_1=requireUtilities();return Heading}var hasRequiredImageUpload,hasRequiredOutTsc,ImageUpload={};function requireImageUpload(){if(hasRequiredImageUpload)return ImageUpload;hasRequiredImageUpload=1;var __awaiter=ImageUpload&&ImageUpload.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};Object.defineProperty(ImageUpload,"__esModule",{value:!0}),ImageUpload.createImageUploadPlugin=void 0;const state_1=require$$0,Utilities_1=requireUtilities();return ImageUpload.createImageUploadPlugin=(config={imageUploadUrl:"",imageFormats:["image/jpg","image/jpeg","image/gif","image/png","image/bmp","image/webp"],csrfToken:"",csrfFieldName:""})=>({createToolbarItem:editor=>{const fileInput=document.createElement("input");fileInput.type="file",fileInput.style.display="none",fileInput.setAttribute("accept",config.imageFormats.join(",")),fileInput.addEventListener("change",(event=>__awaiter(void 0,void 0,void 0,(function*(){const files=event.target.files;if(files&&files[0]){const formData=new FormData;formData.append("image",files[0]),config.csrfFieldName&&config.csrfToken&&formData.append(config.csrfFieldName,config.csrfToken);const resp=yield fetch(config.imageUploadUrl,{method:"POST",body:formData});if(resp.ok){const obj=yield resp.json();!function(view,imageUrl){const transaction=view.state.changeByRange((range=>{const originalText=view.state.sliceDoc(range.from,range.to),{text:text,rangeFrom:rangeFrom,rangeTo:rangeTo}=(0,Utilities_1.trimSelection)(originalText,range);return{changes:{from:rangeFrom,insert:`![${text}](${imageUrl})`,to:rangeTo},range:state_1.EditorSelection.range(rangeFrom+2,rangeFrom+2+text.length)}}));view.dispatch(transaction)}(editor,obj.url)}else{const text=yield resp.text();alert("Error uploading image: "+resp.status+resp.statusText+text)}}}))));const icon=document.createElement("iconify-icon");icon.className+="iconify ",icon.setAttribute("icon","mdi:image-outline"),icon.setAttribute("inline","false"),icon.setAttribute("width","16"),icon.setAttribute("height","16");const buttonElement=document.createElement("button");return buttonElement.appendChild(icon),buttonElement.setAttribute("alt","Select and upload an image"),buttonElement.setAttribute("title","Select and upload an image"),buttonElement.setAttribute("type","button"),buttonElement.addEventListener("click",(()=>{fileInput.click()})),buttonElement.appendChild(fileInput),buttonElement}}),ImageUpload}return getDefaultExportFromCjs(function(){if(hasRequiredOutTsc)return outTsc;hasRequiredOutTsc=1,Object.defineProperty(outTsc,"__esModule",{value:!0}),outTsc.createChunEditor=createChunEditor;const lang_markdown_1=require$$0$1,state_1=require$$0,view_1=require$$2,codemirror_1=require$$3,commands_1=requireDist(),Italic_1=requireItalic(),Bold_1=requireBold(),Code_1=requireCode(),Link_1=requireLink(),Quote_1=requireQuote(),BulletedList_1=requireBulletedList(),Toolbar_1=function(){if(hasRequiredToolbar)return Toolbar;hasRequiredToolbar=1,Object.defineProperty(Toolbar,"__esModule",{value:!0}),Toolbar.Toolbar=void 0,Toolbar.createToolbar=function(editorView){return new Toolbar$1(editorView)};const Italic_1=requireItalic(),Bold_1=requireBold(),Code_1=requireCode(),Link_1=requireLink(),Quote_1=requireQuote(),BulletedList_1=requireBulletedList(),Heading_1=requireHeading();let Toolbar$1=class{constructor(editor,toolbarItems=[]){this.buttonActions=[{text:"Add heading text",icon:"mdi:format-header-3",action:()=>(0,Heading_1.heading)(editor)},{text:"Add bold text, <Ctrl+b>",icon:"mdi:format-bold",action:()=>(0,Bold_1.bold)(editor)},{text:"Add italic text, <Ctrl+i>",icon:"mdi:format-italic",action:()=>(0,Italic_1.italic)(editor)},{text:"Add a quote, <Ctrl+Shift+.>",icon:"mdi:format-quote-close",action:()=>(0,Quote_1.quote)(editor)},{text:"Add code, <Ctrl+e>",icon:"mdi:code-tags",action:()=>(0,Code_1.code)(editor)},{text:"Add a link, <Ctrl+k>",icon:"mdi:link-variant",action:()=>(0,Link_1.link)(editor)},{text:"Add a bulleted list, <Ctrl+Shift+8>",icon:"mdi:format-list-bulleted",action:()=>(0,BulletedList_1.ul)(editor)}];const toolbarElement=document.createElement("div");toolbarElement.className+=" chunmde-toolbar";for(let btnSpec of this.buttonActions){const buttonElement=document.createElement("button"),icon=document.createElement("iconify-icon");icon.className+="iconify ",icon.setAttribute("icon",btnSpec.icon),icon.setAttribute("inline","false"),icon.setAttribute("width","16"),icon.setAttribute("height","16"),buttonElement.appendChild(icon),buttonElement.onclick=btnSpec.action,buttonElement.setAttribute("alt",btnSpec.text),buttonElement.title=btnSpec.text,buttonElement.setAttribute("type","button"),toolbarElement.appendChild(buttonElement)}for(let createToolbarItem of toolbarItems)toolbarElement.appendChild(createToolbarItem(editor));this.dom=toolbarElement}};return Toolbar.Toolbar=Toolbar$1,Toolbar}(),ImageUpload_1=requireImageUpload(),ChunMDE=function(containerId,customConfig={doc:"",toolbar:!0,indentWithTab:!0,lineWrapping:!1,toolbarItems:[]}){const parentElement=document.getElementById(containerId),config={doc:customConfig.doc,extensions:customConfig.extensions},editorView=new view_1.EditorView({state:state_1.EditorState.create(config)});if(parentElement.className+=" chunmde-container",customConfig.toolbar){const toolbar=new Toolbar_1.Toolbar(editorView,customConfig.toolbarItems);parentElement.appendChild(toolbar.dom),this.toolbar=toolbar}parentElement.appendChild(editorView.dom),this.getValue=()=>editorView.state.doc.toString(),this.dom=parentElement,this.editor=editorView};function createChunEditor(customConfig={doc:"",toolbar:!0,indentWithTab:!0,lineWrapping:!1,toolbarItems:[]}){const defaultKeybinds=[Italic_1.italicKeyBinding,Bold_1.boldKeyBinding,Code_1.codeKeyBinding,Link_1.linkKeyBinding,Quote_1.quoteKeyBinding,BulletedList_1.ulKeyBinding],defaultExtensions=[view_1.keymap.of(defaultKeybinds),(0,lang_markdown_1.markdown)({base:lang_markdown_1.markdownLanguage}),codemirror_1.basicSetup],keybinds=[],toolbarItemDelegates=[];return{use(plugin){return plugin.keybind&&keybinds.push(plugin.keybind),plugin.createToolbarItem&&toolbarItemDelegates.push(plugin.createToolbarItem),this},mount:selector=>(customConfig.onUpdateListener&&defaultExtensions.push(view_1.EditorView.updateListener.of(customConfig.onUpdateListener)),customConfig.lineWrapping&&defaultExtensions.push(view_1.EditorView.lineWrapping),customConfig.indentWithTab&&keybinds.push(commands_1.indentWithTab),defaultExtensions.push(view_1.keymap.of(keybinds)),customConfig.extensions=defaultExtensions,customConfig.toolbarItems=toolbarItemDelegates,new ChunMDE(selector,customConfig))}}const Chun={createChunEditor:createChunEditor,createImageUploadPlugin:ImageUpload_1.createImageUploadPlugin};return window.ChunMDE=ChunMDE,window.Chun=Chun,outTsc.default=Chun,outTsc}())}(CM["@codemirror/lang-markdown"],CM["@codemirror/state"],CM["@codemirror/view"],CM.codemirror);
  </script>

  <!-- Theme Toggle Script -->
  <script>
    // Initialize theme
    function initTheme() {
      const theme = localStorage.getItem('theme') ||
        (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.classList.toggle('dark', theme === 'dark');
    }

    // Toggle theme function
    function toggleTheme() {
      const isDark = document.documentElement.classList.contains('dark');
      document.documentElement.classList.toggle('dark', !isDark);
      localStorage.setItem('theme', isDark ? 'light' : 'dark');
    }

    initTheme();

    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
      if (!localStorage.getItem('theme')) {
        document.documentElement.classList.toggle('dark', e.matches);
      }
    });
  </script>

  <!-- Main Application Script -->
  <script defer src="__ASSETS_PREFIX__index.js"></script>
  <!-- <script src="__ASSETS_PREFIX__chunmde.bundle.min.js"></script> -->
</body>
</html>
